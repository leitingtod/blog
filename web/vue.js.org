** Vue实例
*** 构造器
    每个Vue.js应用都是通过构造函数Vue创建一个Vue的根实例启动的：
    #+begin_src javascript
    var vm = Vue({})
    #+end_src

    可以对构造器Vue进行扩展，从而用预定义选项创建可复用的组件构造器：
    #+begin_src javascript
    var MyVue = Vue.extend({})

    var instance = new MyVue()
    #+end_src

    尽管可以命令式地创建扩展实例，不过在多数情况下建议将组件构造器注册为一个自定
    义元素，然后声明式地用在模板中。
*** 属性与方法
    每个 Vue 实例都会代理其 data 对象里所有的属性。

    注意只有这些被代理的属性是响应的，也就是说值的任何改变都是触发视图的重新渲染。
    如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。

    除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有
    前缀 $，以便与代理的 data 属性区分。

    注意，不要在实例属性或者回调函数中（如 vm.$watch('a', newVal =>
    this.myMethod())）使用箭头函数。因为箭头函数绑定父级上下文，所以 this 不会像
    预想的一样是 Vue 实例，而是 this.myMethod 未被定义。
*** 实例生命周期
    每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据
    观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。
    在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑
    的机会。
**** 生命周期
     |----------------------------------------------------------------------------------------|
     | new Vue()                                                                              |
     |----------------------------------------------------------------------------------------|
     | -> beforeCreate                                                                        |
     |----------------------------------------------------------------------------------------|
     | () *ObserveData*                                                                       |
     | () *Init Events*                                                                       |
     |----------------------------------------------------------------------------------------|
     | -> created                                                                             |
     |----------------------------------------------------------------------------------------|
     | ? has 'el' option                                                                      |
     | ? has 'template' option(Yes or when vm.$mount(el) is called                            |
     |----------------------------------------------------------------------------------------|
     | () *compile template into render function(Yes)/compile el's outerHTML as template(No)* |
     |----------------------------------------------------------------------------------------|
     | -> beforeMount                                                                         |
     |----------------------------------------------------------------------------------------|
     | ()create vm.$el and replace "el" with it                                               |
     |----------------------------------------------------------------------------------------|
     | -> mounted                                                                             |
     |----------------------------------------------------------------------------------------|
     | *Mounted*                                                                              |
     | ** /when data changes/                                                                 |
     | -> beforeUpdate                                                                        |
     | () *Virtual DOM re-reander and patch*                                                  |
     | -> updated                                                                             |
     |----------------------------------------------------------------------------------------|
     | ** /when vm.$destroy() is called/                                                      |
     | -> beforeDestroy                                                                       |
     | () *Teardown watchers, child components and event listeners*                           |
     | *Destroyed*                                                                            |
     | -> destroyed                                                                           |
     |----------------------------------------------------------------------------------------|

     示例：
     - *STATE* :: 表示状态
     - ? expr :: 表示分支判断
     - () *action* :: 表示执行的动作
     - -> expr :: 表示钩子函数
     - ** /condition/ :: 表示发生状态转换的条件
** 响应式原理
   Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层
   (model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得非
   常简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。
*** 如何追踪变化
    把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的
    属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。
    Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue
    不支持 IE8 以及更低版本浏览器的原因。

    用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改
    时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter
    的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。

    *每个组件实例* 都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为
    依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关
    联的组件得以更新。
*** 变化检测问题
    受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性
    的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所
    以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

    Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive
    property)。
*** 声明响应式属性
    由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:

    这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，
    也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有
    一点重要的考虑：data 对象就像组件状态的概要，提前声明所有的响应式属性，可以
    让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。
*** 异步更新队列
    Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一
    事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到
    队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。
    然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。

    例如，当你设置 vm.someData = 'new value' ，该组件不会立即重新渲染。当刷新队
    列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心
    这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。
