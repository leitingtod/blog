* 常见性能优化策略
   REFS:
   - http://www.importnew.com/22401.html
   - http://www.importnew.com/13954.html
   - http://blog.csdn.net/zhangweikai966/article/details/24290231
   - http://blog.csdn.net/zhengchao1991/article/details/53579906

** 代码级
*** [[*Java性能优化][Java性能优化]]

** 数据库层
   Books：
   - 高性能MySQL
*** SQL调优
    MySQL自带的慢查询日志或开源的慢查询系统定位具体的出问题的SQL，然后使用
    explain、profile来逐步调优。
**** 慢查询优化
     REFS:
     - https://tech.meituan.com/mysql-index.html
*** 架构层面的调优
    这一类调优包括读写分离、多从库负载均衡、水平和垂直分库分表等方面，一般需要的
    改动较大，但是频率没有SQL调优高，而且一般需要DBA来配合参与。那么什么时候需要
    做这些事情？我们可以通过内部监控报警系统（比如Zabbix），定期跟踪一些指标数据
    是否达到瓶颈，一旦达到瓶颈或者警戒值，就需要考虑这些事情。通常，DBA也会定期监
    控这些指标值。
*** 连接池调优
    我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用
    连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。随着业务访
    问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要
    结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，
    通过反复的几次调试得到最终的调优参数。
** 缓存
   分类：
   - 本地缓存（HashMap/ConcurrentHashMap、Ehcache、Guava Cache等）
   - 缓存服务（Redis/Tair/Memcache等）。

   使用场景：
   - 短时间内相同数据重复查询多次且数据更新不频繁，这个时候可以选择先从缓存查询，
     查询不到再从数据库加载并回设到缓存的方式。此种场景较适合用单机缓存。
   - 高并发查询热点数据，后端数据库不堪重负，可以用缓存来扛。

   造型考虑：
   - 如果数据量小，并且不会频繁地增长又清空（这会导致频繁地垃圾回收），那么可以
     选择本地缓存。具体的话，如果需要一些策略的支持（比如缓存满的逐出策略），可
     以考虑Ehcache；如不需要，可以考虑HashMap；如需要考虑多线程并发的场景，可以
     考虑ConcurentHashMap。
   - 其他情况，可以考虑缓存服务。目前从资源的投入度、可运维性、是否能动态扩容以
     及配套设施来考虑，我们优先考虑Tair。除非目前Tair还不能支持的场合（比如分布
     式锁、Hash类型的value），我们考虑用Redis。

   设计关键点
   - 何时更新缓存？如何保证更新的可靠性和实时性？
     + 设置更新点
     + 设置数据有效期
   - 缓存满了怎么办
     + 设置缓存逐出机制
     + 设置适当的警戒值，当达到此值时，提前排查问题或扩容
     + 尽可能减少不必要的数据的有效期，空出容量
   - 缓存丢失了怎么办
     + 设置适合的持久化策略
   - 缓存被击穿怎么办
     + 缓存被击穿是指缓存在快过期时，突然出现超高并发的访问，这样在缓存失效时会
       从后端DB加载数据，此时超高并发的访问会瞬间把后端DB压垮
     + 业界常见做法是使用mutex
** 异步
*** 使用场景
    针对某些客户端的请求，在服务端可能需要针对这些请求做一些附属的事情，这些事情
    其实用户并不关心或者用户不需要立即拿到这些事情的处理结果，这种情况就比较适合
    用异步的方式处理这些事情。
*** 作用
    - 缩短接口响应时间，使用户的请求快速返回，用户体验更好。
    - 避免线程长时间处于运行状态，这样会引起服务线程池的可用线程长时间不够用，进
      而引起线程池任务队列长度增大，从而阻塞更多请求任务，使得更多请求得不到技术
      处理。
    - 线程长时间处于运行状态，可能还会引起系统Load、CPU使用率、机器整体性能下降
      等一系列问题，甚至引发雪崩。异步的思路可以在不增加机器数和CPU数的情况下，
      有效解决这个问题。

*** 常见做法
    - 使用消息队列中间件
    - 额外开辟线程

** 采用NoSQL数据库
*** 使用场景
    需要结合具体的业务场景，看这块业务涉及的数据是否适合用NoSQL来存储，对数据的
    操作方式是否适合用NoSQL的方式来操作，或者是否需要用到NoSQL的一些额外特性（比
    如原子加减等）。

    如果业务数据不需要和其他数据作关联，不需要事务或者外键之类的支持，而且有可能
    写入会异常频繁，这个时候就比较适合用NoSQL（比如HBase）。
** JVM调优
*** 何时调
    通过监控系统对一些机器关键指标的监控报警，结合gc log 和 jstat等命令的输出，
    再结合线上JVM进程服务的一些关键接口的性能数据和请求体验，定位出JVM是否存在性
    能问题，及是否需要调优。
*** 怎么调
    - 如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count
      以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以
      和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可
      以通过适当增大young区大小或者占比的方式来解决。
    - 如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world
      的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要
      减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，
      一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的
      参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old
      区比率阈值等）来达到一个最优值。
    - 如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，
      从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里
      的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些
      对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是
      搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对
      象。怎么找？综合使用jmap和MAT，基本就能定位到具体的代码。
* Web性能优化
  REFS:
  - http://www.haomou.net/2015/11/05/2015_web_fast/
  - http://blog.csdn.net/w2326ice/article/details/64122838
  - http://blog.csdn.net/w2326ice/article/details/64122372
  - http://caibaojian.com/some-fe
  - http://www.cnblogs.com/mofish/archive/2011/11/03/2234858.html
  - http://blog.csdn.net/Vivian_jay/article/details/58308434?locationNum=11&fps=1
  - http://blog.csdn.net/kobejayandy/article/details/26154511
  - http://www.csdn.net/article/a/2016-02-19/15835262
  - https://www.zhihu.com/question/21658448

** Overview
  前端是庞大的，包括 HTML、 CSS、 JavaScript、Image 、Flash等等各种各样的资源。
  前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，前端优化的目的是什么?
  1. 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。
  2. 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。

  前端优化的途径有很多，按粒度大致可以分为两类，
  - 第一类是页面级别的优化，例如 HTTP 请求数、脚本的无阻塞加载、内联脚本的位置优
    化等

  - 第二类则是代码级别的优化， 例如 javascript中的DOM 操作优化、CSS选择符优化、
    图片优化以及 HTML结构优化等等。

*** 什么是前端性能优化（what）？
    从用户访问资源到资源完整的展现在用户面前的过程中，通过技术手段和优化策略，缩
    短每个步骤的处理时间从而提升整个资源的访问和呈现速度。


*** 为什么要做前端性能优化（why）？
    在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性
    能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导
    致网站访问速度变慢，用户体验低下，最终导致用户流失。

*** 前端性能优化的原则（rule）
    1. 不要按照准则照本宣科的做，需要根据实际情况因地制宜；
    2. 不出bug！

*** 从浏览器发起请求到页面能正常浏览都有哪些阶段（process）？
    预处理——>DNS解析——>建立连接——>发起请求——>等待响应——>接受数据——>处理元素——>布
    局渲染

*** 性能优化的具体方法（way）
**** 一）内容层面
     1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名）
     2、避免重定向（/还是需要的）
     3、切分到多个域名
     4、杜绝404

**** 二）网络传输阶段
***** 1、减少传输过程中实体的大小
      1）缓存
      2）cookie优化
      3）文件压缩（Accept-Encoding：g-zip）

***** 2、减少请求的次数
      1）文件适当的合并
      2）雪碧图

***** 3、异步加载（并发,requirejs）

***** 4、预加载、延后加载、按需加载

**** 三）渲染阶段
     1、js放底部，css放顶部
     2、减少重绘和回流
     3、合理使用Viewport 等meta头部
     4、减少dom节点
     5、BigPipe

**** 四）脚本执行阶段
     1、缓存节点，尽量减少节点的查找
     2、减少节点的操作（innerHTML）
     3、避免无谓的循环，break、continue、return的适当使用
     4、事件委托

     简单说就是：
     - 传输层面：减少请求数，降低请求量，
     - 执行层面：减少重绘&回流。
** 使用CDN
   CDN【Content Delivery Network】，即内容分发网络。属于http缓存技术中的一种。

   其基本思路是尽可能避开网络上可能影响数据传输速度和稳定性的瓶颈和环节，使内容
   传输的更快、更稳定。CDN管理分布在多个地理位置上的服务器，其系统能够实时地根据
   网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的
   请求重定向到一个能提供最好用户体验的服务节点上。

   总的来说，内容服务基于缓存服务器，也称作代理缓存【网关缓存】，它位于网络的边
   缘，据用户仅“一跳”之隔。代理缓存提供数据中心服务器的一个镜像，当用户对某网
   址访问的请求并非第一次，那么代理缓存在很大概率上缓存了域名，就不需要大费周章
   通过DNS【域名服务系统】来获取对应域名。
** 避免重定向
   301：永久重定向，抓取新内容的同时也将旧的网址替换为重定向之后的网址；
   302：暂时重定向，抓取新的内容而保留旧的网址
   SEO：302好于301
   重定向会增加http请求数，但必要的重定向有利于提高用户体验
** yahoo军规35条
** 尽量减少HTTP请求
   - 合并JS脚本和CSS文件
   - 复用CSS Sprites，尽量合并小图片
** 复用浏览器缓存
   根据服务器端响应的header, 一个文件对浏览器而言，有几种不同的缓存状态：
   1. 服务端指明不要缓存
   2. 服务端未指明是否需要缓存
   3. 服务端指明本地缓存是否最新的，若不是，则返回304，指示浏览器下载新版本
   4. 服务端指明需要缓存，并设置有效期。缓存未失效时，浏览器直接使用本地缓存，不
      与服务端产生任何通信。
** 使用压缩功能，减少传输时间
** 预载入图片，JS
   预载入图像最简单的方法是在 JavaScript 中实例化一个新 Image() 对象，然后将需要
   载入的图像的 URL 作为参数传入。
   #+begin_src javascript
   function preLoadImage(url) {
     var img = new Image();
     img.src = url;
   }
   #+end_src
** 将JS脚本放到底部
   脚本放在顶部带来的问题：
   1. 使用脚本时，对于位于脚本以下的内容，逐步呈现将被阻塞
   2. 在下载脚本时会阻塞并行下载

   放在底部可能会出现JS错误问题，当脚本没加载进来，用户就触发脚本事件。要综合考
   虑情况。
** 将样式文件放在页面顶部
   如果样式表任在加载，构建呈现树就是一种浪费，样式文件放在页面底部可能会出现两种情况：
   1. 白屏
   2. 无样式内容的闪烁
** 使用外部的JS和CSS
   将内联的JS和CSS做成外部的JS、CSS。减少重复下载内联的JS和CSS。
** 切分组件到多个域
   主要的目的是提高页面组件并行下载能力。但不要跨太多域名，建议采用2个子域名。
** 精简JS
   可以做到两个级别
   1. 精简：从代码中移除不必要的字符以减少其大小，
   2. 混淆：在精简的同时，还会改写代码，函数、变量名被转换成更短的字符串
** 精简CSS
   从代码中移除不必要的字符以减少其大小，
** 精简图片、Flash
   对大图片、Flash，要在效果和大小之间做出平衡。
* Java性能优化
  REFS:
  - http://developer.51cto.com/art/201511/496263.htm
  - http://www.importnew.com/16181.html
  - http://blog.csdn.net/zhangweikai966/article/details/24290315
  - http://www.cnblogs.com/chinafine/articles/1787118.html

** 尽量指定类、方法的final修饰符
   带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如
   java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，
   为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该 类
   所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升
   Java运行效率作用重大，具体参见Java运行期优 化。此举能够使性能平均提高50%。

** 尽量重用对象
   特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代
   替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃
   圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。

** 尽可能使用局部变量
   调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，
   如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方
   法的运行结束，这些内容就没了，不需要额外的垃圾回收。

** 及时关闭流
   Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以
   释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的
   后果。

** 尽量减少对变量的重复计算
   明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈
   帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：

** 尽量采用懒加载的策略，即在需要的时候才创建
** 慎用异常
   异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名
   为fillInStackTrace()的本地同步方 法，fillInStackTrace()方法检查堆栈，收集调用
   跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创
   建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。

** 不要在循环中使用try…catch…
   把其放在最外层除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强
   迫症一点，八成就要骂你为什么写出这种垃圾代码来了

** 如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度
** 当复制大量数据时，使用System.arraycopy()命令
   使用'system.arraycopy ()'代替通过来循环复制数组

** 如果只是查找单个字符的话，用charat()代替startswith()
** 不要在循环中调用synchronized(同步)方法
   方法的同步需要消耗相当大的资源，在一个循环中调用它绝对不是一个好主意。

** 用'stringtokenizer' 代替 'indexof()' 和'substring()'
   字符串的分析在很多应用中都是常见的。使用indexof()和substring()来分析字符串容
   易导致 stringindexoutofboundsexception。而使用stringtokenizer类来分析字符串则
   会容易一些，效率也会高一些。

** 确定 stringbuffer的容量
   stringbuffer的构造器会创建一个默认大小(通常是16)的字符数组。在使用中，如果超
   出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再
   丢弃旧的数组。在大多数情况下，你可以在创建stringbuffer的时候指定大小，这样就
   避免了在容量不够的时候自动增长，以提高性能。

** 尽量使用基本数据类型代替对象。
** 用简单的数值计算代替复杂的函数计算，比如查表方式解决三角函数问题
** StringBuffer,StringBuilder 的区别
   区别在于java.lang.StringBuffer 线程安全的可变字符序列。一个类似于String的字符串缓冲区，
   但不能修改。StringBuilder与该类相比，通常应该优先使用 StringBuilder类，因为她
   支持所有相同的操作，但由于她不执行同步，所以速度更快。为了获得更好的性能，在
   构造StringBuffer或 StringBuilder时应尽量指定她的容量。当然如果不超过16个字符
   时就不用了。 相同情况下，使用StringBuilder比使用 StringBuffer仅能获得10%~15%
   的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用StringBuffer。
** 如非必要，循环内不要不断创建对象引用
   #+begin_src java
   for(int i=1; i<count; i++) {
       Object obj = new Object();
   }

   Object obj = null;
   for(int i=1; i<count; i++) {
       obj = new Object();
   }
   #+end_src

** 基于效率和类型检查的考虑，应该尽可能使用array
   无法确定数组大小时才使用ArrayList

** 尽量使用HashMap、ArrayList、StringBuilder
   除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使
   用同步机制而导致了性能开销

*** StringBuilder
   一般来说，使用 StringBuilder 的效果要优于使用 + 操作符。如果可能的话请在需要
   跨多个方法传递引用的情况下选择 StringBuilder，因为 String 要消耗额外的资源。
   JOOQ在生成复杂的SQL语句便使用了这样的方式。在整个抽象语法树（AST Abstract
   Syntax Tree）SQL传递过程中仅使用了一个 StringBuilder 。

   更加悲剧的是，如果你仍在使用 StringBuffer 的话，那么用 StringBuilder 代替 StringBuffer 吧，毕竟需要同步字符串的情况真的不多。

** 不要将数组声明为public static final
   因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变
   的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变

** 尽量在合适的场合使用单例
   使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方
   都适用于单例，简单来说，单例主要适用于以下三个方面：
   1. 控制资源的使用，通过线程同步来控制资源的并发访问
   2. 控制实例的产生，以达到节约资源的目的
   3. 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信

** 尽量避免随意使用静态变量
   要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所
   占有的堆内存的

** 及时清除不再需要的会话
   为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。
   当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统 会把部分数据转移
   到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到
   磁盘，甚至可能抛出内存不足的异常。如果会话要被转 储到磁盘，那么必须要先被序列
   化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，
   应当及时调用HttpSession的 invalidate()方法清除会话。

** 实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历
   这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接
   口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改 其行为，从
   而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现
   RandomAccess接口的类实例，假如是随机访问的，使用普通 for循环效率将高于使用
   foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。

** 使用同步代码块替代同步方法
   这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一
   整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步
   的代码也进行了同步，影响了代码执行效率。

** 将常量声明为static final，并以大写命名
   这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另
   外，将常量的名字以大写命名也可以方便区分出常量与变量

** 不要创建一些不使用的对象，不要导入一些不使用的类
   这毫无意义，如果代码中出现”The value of the local variable i is not
   used”、”The import java.util is never used”，那么请删除这些无用的内容

** 程序运行过程中避免使用反射
   关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效
   率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制， 特别是Method的
   invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项
   目启动的时候通过反射实例化出一个对象并放入 内存—-用户只关心和对端交互的时候获
   取最快的响应速度，并不关心对端的项目启动花多久时间。

** 使用数据库连接池和线程池
   这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频
   繁地创建和销毁线程

** 使用带缓冲的输入输出流进行IO操作
   带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、
   BufferedOutputStream，这可以极大地提升IO效率

** 顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList
   这个，理解ArrayList和LinkedList的原理就知道了

** 不要让public方法中有太多的形参
   public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：
   1. 违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合
   2. 参数太多势必导致方法调用的出错概率增加

** 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+”"最慢
** 使用最有效率的方式去遍历Map
   遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使
   用的、效率最高的方式是 Iterator

** 对资源的close()建议分开操作
   万一XXX.close()抛异常了，那么就进入了cath块中 了，YYY.close()不会执行，YYY这
   块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。

** 避免使用正则表达式
   正则表达式给人的印象是快捷简便。但是在 N.O.P.E 分支中使用正则表达式将是最糟糕
   的决定。如果万不得已非要在计算密集型代码中使用正则表达式的话，至少要将
   Pattern 缓存下来，避免反复编译Pattern。

   正则表达式是十分有用，但是在使用时也要付出代价。尤其是在 N.O.P.E 分支深处时，
   要不惜一切代码避免使用正则表达式。还要小心各种使用到正则表达式的JDK字符串方法，
   比如 String.replaceAll() 或 String.split()。可以选择用比较流行的开发库，比如
   Apache Commons Lang 来进行字符串操作。

** 不要使用iterator()方法
   这条建议不适用于一般的场合，仅适用于在 N.O.P.E 分支深处的场景。

   无论是从易读写的角度来说，还是从API设计的角度来说迭代器、Iterable接口和
   foreach 循环都是非常好用的。但代价是，使用它们时是会额外在堆上为每个循环子创
   建一个对象。如果循环要执行很多很多遍，请注意避免生成无意义的实例，最好用基本
   的指针循环方式来代替上述迭代器、Iterable接口和 foreach 循环。

** 不要调用高开销方法
** 使用原始类型和栈
** 避免递归
** 使用entrySet()
   因为很多看似时间复杂度为 O(1) 的访问操作其实是由一系列的操作组成的。而且访问
   本身也不是免费的。至少，如果不得不使用map的话，那么要用 entrySet() 方法去迭代！
   这样的话，我们要访问的就仅仅是Map.Entry的实例。

** 使用EnumSet或EnumMap
   在某些情况下，比如在使用配置map时，我们可能会预先知道保存在map中键值。如果这
   个键值非常小，我们就应该考虑使用 EnumSet 或 EnumMap，而并非使用我们常用的
   HashSet 或 HashMap。

   如果有一个全局的map配置（例如只有一个实例），在增加访问速度的压力下，EnumMap
   会获得比 HashMap 更加杰出的表现。原因在于 EnumMap 使用的堆内存比 HashMap 要少
   一位（bit），而且 HashMap 要在每个键值上都要调用 hashCode() 方法和 equals()
   方法。

** 优化自定义hasCode()方法和equals()方法
   在不能使用EnumMap的情况下，至少也要优化 hashCode() 和 equals() 方法。一个好的
   hashCode() 方法是很有必要的，因为它能防止对高开销 equals() 方法多余的调用。

** 考虑使用set而并非单个元素(For SQL)
