* 语言特性
** Java 1.8 更新
   1. default关键字

      在java里面，我们通常都是认为接口里面是只能有抽象方法，不能有任何
      方法的实现的，那么在jdk1.8里面打破了这个规定，引入了新的关键字
      default，通过使用default修饰方法，可以让我们在接口里面定义具体的
      方法实现。

      default方法是所有的实现类都不需要去实现的就可以直接调用，那么比如
      说jdk的集合List里面增加了一个sort方法，那么如果定义为一个抽象方法，
      其所有的实现类如arrayList,LinkedList等都需要对其添加实现，那么现
      在用default定义一个默认的方法之后，其实现类可以直接使用这个方法了，
      这样不管是开发还是维护项目，都会大大简化代码量。

   2. Lambda 表达式、局部变量限制、函数式接口

   3. 流

      流是Java API的新成员，它允许我们以声明性方式处理数据集合（通过查
      询语句来表达，而不是临时编写一个实现）。就现在来说，我们可以把它
      们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，也就
      是说我们不用写多线程代码了。

      Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历
      一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。而
      和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串
      行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读
      下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都
      在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于
      Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。

   4. 方法与构造函数引用

      jdk1.8提供了另外一种调用方式::，当 你 需 要使用 方 法 引用时 ，
      目 标引用 放 在 分隔符::前 ，方法 的 名 称放在 后 面 ，即
      ClassName :: methodName 。

   5. 多重注解

   6. Date Api更新　　
*** 参考
    - https://www.cnblogs.com/jacksontao/p/8608291.html
    - https://www.cnblogs.com/yepei/p/5650440.html
** Annontation
   Java5开始引入的新特征，中文名称叫注解。

   它提供了一种安全的类似注释的机制，用来将任何的信息或元数据
   （metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元
   素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程
   序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰
   符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的
   声明语句中。

   Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行
   解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，
   仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。

*** 注解的用处
    1. 生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param
       @return 等
    2. 跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2依赖注入，未
       来java开发，将大量注解配置，具有很大用处;
    3. 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并
       不是覆盖了超类方法，则编译时就能检查出。

*** 元注解
    java.lang.annotation提供了四种元注解，专门注解其他的注解（在自定义
    注解的时候，需要使用到元注解）：
    - @Documented – 表示是否将注解信息添加在java文档中。
    - @Retention – 什么时候使用该注解
      - RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之
        后就不再有任何意义，所以它们不会写入字节码。@Override,
        @SuppressWarnings都属于这类注解。
      - RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理
        中有用。注解默认使用这种方式
      - RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因
        此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这
        种方式。
    - @Target – 注解用于什么地方。默认值为任何元素，表示该注解用于什么
      地方。可用的ElementType参数包括：
      - ElementType.CONSTRUCTOR:用于描述构造器
      - ElementType.FIELD:成员变量、对象、属性（包括enum实例）
      - ElementType.LOCAL_VARIABLE:用于描述局部变量
      - ElementType.METHOD:用于描述方法
      - ElementType.PACKAGE:用于描述包
      - ElementType.PARAMETER:用于描述参数
      - ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明
    - @Inherited – 是否允许子类继承该注解。如果一个使用了@Inherited修
      饰的annotation类型被用于一个class，则这个annotation将被用于该
      class的子类。

*** 自定义注解：
    自定义注解类编写的一些规则:
    1. Annotation型定义为@interface, 所有的Annotation会自动继承
       java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.
    2. 参数成员只能用public或默认(default)这两个访问权修饰
    3. 参数成员只能用基本类型
       byte,short,char,int,long,float,double,boolean八种基本数据类型和
       String、Enum、Class、annotations等数据类型,以及这一些类型的数组.
    4. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取
       Annotation对象,因为你除此之外没有别的获取注解对象的方法
    5. 注解也可以没有定义成员, 不过这样注解就没啥用了

    PS:自定义注解需要使用到元注解

** final
   final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。
   
   1. 类

      当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个
      类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变
      量可以根据需要设为final，但是要注意final类中的所有成员方法都会被
      隐式地指定为final方法。
   2. 方法
      
      使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承
      类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将
      final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用
      带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行
      这些优化了。

   3. 变量（包括参数变量）

      final成员变量表示常量，只能被赋值一次，赋值后值不再改变，必须要
      显示初始化。

      引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对
      象的内容是可变的。
*** 参考
    - https://www.cnblogs.com/xiaoxi/p/6392154.html

** AQS
   AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一
   系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依
   赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。

*** 参考
    - https://www.cnblogs.com/waterystone/p/4920797.html
    - https://www.jianshu.com/p/da9d051dcc3d
    
** 日期时间
   常用的日期时间类：java.util.Date类->是在Java 1.0中；而
   java.util.Calendar类->是在Java 1.1中。

   java.util.Date缺点：（1）年份是从1970开始算的；（2）DateFormat方法
   不是线程安全的。

   java.util.Calendar缺点：和Date类一样都是可变的。而且经常会同时用
   Date和Calendar，很混乱。

   使用Java8，新的日期时间API引入覆盖旧的日期时间API的以下缺点:
   1. 非线程安全  - java.util.Date不是线程安全的，因此开发者必须在使用
      日期处理并发性问题。新的日期时间API是不可变的，并且没有setter方
      法。

   2. 设计不佳 - 默认的开始日期从1900年，开始每月从1天从0开始，所以没
      有统一。不直接使用方法操作日期。新的API提供了这样操作实用方法。

   3. 困难的时区处理 - 开发人员必须编写大量的代码来处理时区的问题。新
      的API设计开发保持特定领域设计。

*** 参考
    - https://www.cnblogs.com/comeboo/p/5378922.html
    - https://blog.csdn.net/timchen525/article/details/75041561
** 参考
   - https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html
* 集合
** HashMap
   HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。   
*** 默认容量为何是16？为何是2的整数倍？
    初始容量为1<<4，即16。负载因子是0.75，当存入的元素占比超过
    16*0.75=12时，进行扩容。在容量不超过int类型的范围时，将大小扩为原
    来的2倍。

    因为保存元素的位置是由 hashcode 与 大小做运算的。当length的大小取2
    的整数次幂时，可以保证散列的均匀性。

*** 高性能场景下，HashMap的优化使用建议
    1. 考虑加载因子地设定初始大小
    2. 减小加载因子
    3. String类型的key，不能用==判断或者可能有哈希冲突时，尽量减少长度
    4. 使用定制版的EnumMap
    5. 使用IntObjectHashMap
    
*** 参考
    - http://www.importnew.com/21429.html
    - http://calvin1978.blogcn.com/articles/latency.html

** HashSet
   HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，
   第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和
   hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相
   等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。

   HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。
   Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列
   次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非
   synchronized的，但collection框架提供方法能保证HashMap synchronized，
   这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。

** ConcurrentHashMap  
   简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继
   承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个
   segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线
   程安全。

   concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理
   解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以
   理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作
   分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，
   但是一旦初始化以后，它是不可以扩容的。

   loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这
   个负载因子是给每个 Segment 内部使用的。

   get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。添加节点的
   操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所
   以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个
   segment 中发生了 put 或 remove 操作。
   1. put 操作的线程安全性

      初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的
      数组。
     
      添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作
      在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题
      就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个
      依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。扩容。

      扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属
      性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果
      get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么
      put 操作的可见性保证就是 table 使用了 volatile 关键字。
   2. remove 操作的线程安全性

      如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问
      题。

      如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头
n      结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然
      使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见
      性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。
      2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前
      驱节点中，这里的并发保证就是 next 属性是 volatile 的。

   Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其
   由 数组+链表+红黑树 组成。

** 参考
   - http://www.importnew.com/28263.html
* 多线程
** 使用场景
   1. 后台任务: 定时发送邮件
   2. 异步处理: 
   3. 分布式计算
   4. 数据库数据分析、数据迁移
   5. 耗时的操作
** ThreadLocal
   ThreadLocal并非是一个线程的本地实现版本，它并不是一个Thread，而是
   threadlocalvariable(线程局部变量)。也许把它命名为ThreadLocalVar更加
   合适。线程局部变量(ThreadLocal)其实的功用非常简单，就是为每一个使用
   该变量的线程都提供一个变量值的副本，是Java中一种较为特殊的线程绑定机
   制，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲
   突。

   从线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只
   要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线
   程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。

   ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路
   很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。


   ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。

   ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副本来
   运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，
   也减少了线程并发控制的复杂度。
 
   ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用比
   synchronized要简单得多。
 
   ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与
   synchronized有本质的区别。synchronized是利用锁的机制，使变量或代码块
   在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量
   的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了
   多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程
   间通信时能够获得数据共享。
 
   Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔
   离。
 
   当然ThreadLocal并不能替代synchronized,它们处理不同的问题域。
   Synchronized用于实现同步机制，比ThreadLocal更加复杂。
  
*** 参考
    - ThreadLocal: http://blog.51cto.com/lavasoft/51926
    - https://www.jianshu.com/p/98b68c97df9b

** 线程池
   为什么要用线程池:
   1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行
      多个任务。
   2. 可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消
      耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的
      越多，消耗的内存也就越大，最后死机)。
   
   Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是
   一个线程池，而只是一个执行线程的工具。真正的线程池接口是
   ExecutorService。

   ExecutorService关闭方法：
   1. shutdown()
      
      将线程池状态置为SHUTDOWN,并不会立即停止：
      1. 停止接收外部submit的任务
      2. 内部正在跑的任务和队列里等待的任务，会执行完
      3. 等到第二步完成后，才真正停止

   2. shutdownNow()
      
      将线程池状态置为STOP。企图立即停止，事实上不一定：
      1. 跟shutdown()一样，先停止接收外部提交的任务
      2. 忽略队列里等待的任务
      3. 尝试将正在跑的任务interrupt中断
      4. 返回未执行的任务列表

      它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但
      是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、
      Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。
      所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必
      须要等待所有正在执行的任务都执行完成了才能退出。

   3. awaitTermination(long timeOut, TimeUnit unit)
      
      当前线程阻塞，直到:
      1. 等所有已提交的任务（包括正在跑的和队列中等待的）执行完
      2. 或者等超时时间到
      3. 或者线程被中断，抛出InterruptedException

      然后返回true（shutdown请求后所有任务执行完毕）或false（已超时）

  【强制】线程池不允许使用 Executors 去创建，而是通过
   ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的
   运行规则，规避资源耗尽的风险。

   public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) 

   1. corePoolSize - 线程池核心池的大小。
   2. maximumPoolSize - 线程池的最大线程数。
   3. keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。
   4. unit - keepAliveTime 的时间单位。
   5. workQueue - 用来储存等待执行任务的队列。
   6. threadFactory - 线程工厂。
   7. handler - 拒绝策略。

   为什么：
   1. 明确线程池大小

      线程池有两个线程数的设置，一个为核心池线程数，一个为最大线程数。
      在创建了线程池后，默认情况下，线程池中并没有任何线程，等到有任务
      来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者
      prestartCoreThread()方法。当创建的线程数等于 corePoolSize 时，会
      加入设置的阻塞队列。当队列满时，会创建线程执行任务直到线程池中的
      数量等于maximumPoolSize。

   2. 明确阻塞队列
      1. ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
      2. LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
      3. PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
      4. DelayQueue： 一个使用优先级队列实现的无界阻塞队列。
      5. SynchronousQueue： 一个不存储元素的阻塞队列。
      6. LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列。
      7. LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。

   3. 明确拒绝策略
      1. ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出
         RejectedExecutionException异常。 (默认)
      2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异
         常。
      3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最 前面的任
         务，然后重新尝试执行任务（重复此过程）
      4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
 
   Executors 各个方法的弊端：
   1. newFixedThreadPool 和 newSingleThreadExecutor:主要问题是堆积的请
      求处理队列可能会耗费非常大的内存，甚至 OOM。
   2. newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程数最
      大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。

   让我们再看看Executors提供的那几个工厂方法。

   1. newSingleThreadExecutor
   
      创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当
      于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会
      有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务
      的提交顺序执行。

      new ThreadPoolExecutor(1, 1,0L,TimeUnit.MILLISECONDS,new
      LinkedBlockingQueue<Runnable>());

   2. newFixedThreadPool
      
      创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达
      到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果
      某个线程因为执行异常而结束，那么线程池会补充一个新线程
      
      new ThreadPoolExecutor(nThreads, nThreads, 0L,
      TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());

   3. newCachedThreadPool

      创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线
      程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，
      此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大
      小做限制，（或者说JVM）能够创建的最大线程大小。
      
      new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,
      TimeUnit.SECONDS,new SynchronousQueue<Runnable>());

   4. newScheduledThreadPool

      创建一个定长线程池，支持定时及周期性任务执行。

   
*** 参考
    - https://blog.csdn.net/qq_33300570/article/details/78394188
    - https://blog.csdn.net/huanyuminhao/article/details/51974171
    - https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/
    - https://blog.csdn.net/u012168222/article/details/52790400

** 确保三个线程顺序执行
   https://blog.csdn.net/suyimin2010/article/details/81025080
* JVM
** Minor GC ，Full GC 触发条件
   Minor GC触发条件：
   1. 当Eden区满时，触发Minor GC。

   Full GC触发条件：
   1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
   2. 老年代空间不足
   3. 方法去空间不足
   4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
   5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可
      用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

