#+Ref: https://waylau.gitbooks.io/servlet-3-1-specification/
* 总览
** 什么是Servlet
   servlet 是基于 Java 的 Web 组件，由容器进行管理，来生成动态内容。像
   其他基于 Java 的组件技术一样，servlet 也是基于平台无关的 Java 类格
   式，被编译为平台无关的字节码，可以被基于 Java 技术的 Web 服务器动态
   加载并运行。容器（Container），有时候也叫做 servlet 引擎，是 Web 服
   务器为支持 servlet 功能扩展的部分。客户端通过 servlet 容器实现的
   request/response paradigm（请求/应答模式） 与 Servlet 进行交互。

** 什么是Servlet容器
   Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部
   分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，
   并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命
   周期里 Servlet。

   Servlet 容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本
   地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用
   Web 功能的应用服务器中。所有的 Servlet 容器必须支持 HTTP 协议用于请
   求和响应，但额外的基于 请求/响应 的协议，如 HTTPS (HTTP over SSL)的
   支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和
   HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机
   制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将
   Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规
   范直接对请求作出响应而不交给 Servlet 进行处理。

   Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台
   标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或
   更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。
   比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限
   制 Thread 对象的创建。
** Servlet 与其他技术的对比
   从功能上看，servlet 位于Common Gateway Interface（公共网关接口，简
   称 CGI）程序和私有的服务器扩展如 Netscape Server API（NSAPI）或
   Apache Modules 这两者之间。

   1. 相对于其他服务器扩展机制 Servlet 有如下优势：
   2. 它们通常比 CGI 脚本更快，因为采用不同的处理模型。
   3. 它们采用标准的 API 从而支持更多的Web 服务器。
   4. 它们拥有 Java 编程语言的所有优势，包括容易开发和平台无关。
   5. 它们可以访问 Java 平台提供的大量的 API。
* Servlet 接口
  Servlet 接口是 Java Servlet API 的核心抽象。所有 Servlet 类必须直接
  或间接的实现该接口，或者更通常做法是通过继承一个实现了该接口的类从而
  复用许多共性功能。目前有 GenericServlet 和 HttpServlet这两个类实现了
  Servlet 接口。大多数情况下，开发者只需要继承HttpServlet 去实现自己的
  Servlet 即可。

** 请求处理方法
   基础的 Servlet 接口定义了 service 方法用于处理客户端的请求。当有请
   求到达时，该方法由 servlet 容器路由到一个 servlet 实例来调用。

   Web 应用的并发请求处理通常需要 Web 开发人员去设计适合多线程执行的
   Servlet，从而保证 service 方法能在一个特定时间点处理多线程并发执行。

   Servlet 默认是线程不安全的，需要开发人员处理多线程问题。
   
   通常 Web 容器对于并发请求将使用同一个 servlet 处理，并且在不同的线
   程中并发执行 service 方法。

*** 基于 HTTP 规范的请求处理方法
    HttpServlet 抽象子类在基本的 Servlet 之上添加了些协议相关的方法，
    并且这些方法能根据 HTTP 请求类型自动的由 HttpServlet 中实现的
    service 方法转发到相应的协议相关的处理方法上。
** 实例数量
   对于未托管在分布式环境中（默认）的 servlet 而言，servlet 容器对于每
   一个 Servlet 声明必须且只能产生一个实例。不过，如果 Servlet实现了
   SingleThreadModel 接口，servlet 容器可以选择实例化多个实例以便处理
   高负荷请求或者串行化请求到一个特定实例。

   如果 servlet 以分布式方式进行部署，容器可以为每个 Java Virtual
   Machine (JVM™) 的每个 Servlet 声明产生一个实例。但是，如果在分布式
   环境中 servlet 实现了 SingleThreadModel 接口，此时容器可以为每个容
   器的 JVM 实例化多个 Servlet 实例。

*** 关于 Single Thread Model
   SingleThreadModel 接口的作用是保证一个特定 servlet 实例的service 方
   法在一个时刻仅能被一个线程执行，一定要注意，此保证仅适用于每一个
   servlet 实例，因此容器可以选择池化这些对象。

   有些对象可以在同一时刻被多个 servlet 实例访问，如 HttpSession 实例，
   可以在一个特定的时间对多个 Servlet 可用，包括那些实现了
   SingleThreadModel 接口的 Servlet。

   建议开发人员采取其他手段来解决这些问题,而不是实现这个接口,如避免使
   用实例变量或同步的代码块访问这些资源。SingleThreadModel 接口已经在
   本版本规范中弃用。
* Servlet 生命周期
  Servlet 是按照一个严格定义的生命周期被管理，该生命周期规定了Servlet
  如何被加载、实例化、初始化、处理客户端请求，以及何时结束服务。该声明
  周期可以通过 javax.servlet.Servlet 接口中的 init、service 和 destroy
  这些 API 来表示，所有 Servlet 必须直接或间接的实现 GenericServlet 或
  HttpServlet 抽象类。
  
** 加载和实例化
   Servlet 容器负责加载和实例化 Servlet。加载和实例化可以发生在容器启
   动时，或者延迟初始化直到容器决定有请求需要处理时。

   当 Servlet 引擎启动后，servlet 容器必须定位所需要的 Servlet 类。
   Servlet 容器使用普通的 Java 类加载设施加载 Servlet 类。可以从本地文
   件系统或远程文件系统或者其他网络服务加载。
   
   加载完 Servlet 类后，容器就可以实例化它并使用了。

** 初始化
   servlet 对象实例化后，容器必须初始化 servlet 之后才能处理客户端的请
   求。初始化的目的是以便 Servlet 能读取持久化配置数据，初始化一些代价
   高的资源（比如JDBC™ API 连接），或者执行一些一次性的动作。

   容器通过调用 Servlet 实例的 init 方法完成初始化，init 方法定义在
   Servlet 接口中，并且提供一个唯一的 ServletConfig 接口实现的对象作为
   参数，该对象每个 Servlet 实例一个。

   配置对象允许 Servlet 访问由 Web 应用配置信息提供的键-值对的初始化参
   数。该配置对象也提供给Servlet 去访问一个 ServletContext 对象，
   ServletContext 描述了Servlet 的运行时环境。

*** 初始化时的错误条件
    在初始化阶段，servlet 实例可能抛出 UnavailableException 或
    ServletException 异常。在这种情况下，servlet 不能放置到活动服务中，
    servlet 容器必须释放它。如果初始化没有成功，destroy 方法不应该被调
    用。

    在实例初始化失败后容器可能再实例化和初始化一个新的实例。此规则的例
    外是，当抛出的 UnavailableException 表示一个不可用的最小时间，容器
    在创建和初始化一个新的 servlet 实例之前必须等待一段时间。

** 请求处理
   
*** 多线程问题
    servlet 容器可以并发的发送多个请求到 servlet 的 service 方法。为了
    处理这些请求，Servlet 开发者必须为 service 方法的多线程并发处理做
    好充足的准备。

    一个替代的方案是开发人员实现 SingleThreadModel 接口，由容器保证一
    个 service 方法在同一个时间点仅被一个请求线程调用，但是此方案是不
    推荐的。servlet 容器可以通过串行化访问 servlet的请求，或者维护一个
    servlet 实例池完成该需求。如果 Web 应用中的 servlet 被标注为分布式
    的，容器应该为每一个分布式应用程序的 JVM 维护一个 Servlet 实例池。

    对于那些没有实现 SingleThreadModel 接口的 servlet，但是它的service
    方法（或者是那些 HttpServlet 中通过 service 方法分派的doGet、
    doPost 等分派方法）是通过 synchronized 关键词定义的，servlet 容器
    不能使用实例池方案，并且只能使用序列化请求进行处理。强烈推荐开发人
    员不要去同步 service 方法（或者那些由 service 分派的方法），因为这
    将严重影响性能。

*** 请求处理时的异常
    servlet 在处理一个请求时可能抛出 ServletException 或
    UnavailableException 异常。ServletException 表示在处理请求时出现了
    一些错误，容器应该采取适当的措施清理掉这个请求。

    UnavailableException 表示 servlet 目前无法处理请求，或者临时性的或
    者永久性的。

    如果 UnavailableException 表示的是一个永久性的不可用，servlet 容器
    必须从服务中移除这个 servlet，调用它的 destroy 方法，并释放servlet
    实例。所有被容器拒绝的请求，都会返回一个 SC_NOT_FOUND (404) 响应。

    如果 UnavailableException 表示的是一个临时性的不可用，容器可以选择
    在临时不可用的这段时间内路由任何请求到 Servlet。所以在这段时间内被
    容器拒绝的请求，都会返回一个 SC_SERVICE_UNAVAILABLE (503) 响应状态
    码，且同时会返回一个 Retry-After 头指示此 servlet 什么时候可用。容
    器可以选择忽略永久性和临时性不可用的区别，并把UnavailableException
    视为永久性的，从而 servlet 抛出UnavailableException 后需要把它从服
    务中移除。

*** 异步处理
    有时候，Filter及/或 Servlet 在生成响应之前必须等待一些资源或事件以
    便完成请求处理。比如，Servlet 在进行生成一个响应之前可能等待一个可
    用的 JDBC 连接，或者一个远程 web 服务的响应，或者一个 JMS 消息，或
    者一个应用程序事件。在 Servlet 中等待是一个低效的操作，因为这是阻
    塞操作，从而白白占用一个线程或其他一些受限资源。许多线程为了等待一
    个缓慢的资源比如数据库经常发生阻塞，可能引起线程饥饿，且降低整个
    Web 容器的服务质量。

    引入了异步处理请求的能力，使线程可以返回到容器，从而执行更多的任务。
    当开始异步处理请求时，另一个线程或回调可以或者产生响应，或者调用完
    成（complete）或请求分派（dispatch），这样，它可以在容器上下文使用
    AsyncContext.dispatch 方法运行。一个典型的异步处理事件顺序是：
    1. 请求被接收到，通过一系列如用于验证的等标准的 filter 之后被传递
       到 Servlet。
    2. servlet 处理请求参数及（或）内容体从而确定请求的类型。
    3. 该 servlet 发出请求去获取一些资源或数据，例如，发送一个远程web
       服务请求或加入一个等待 JDBC 连接的队列。
    4. servlet 不产生响应并返回。
    4. 过了一段时间后，所请求的资源变为可用，此时处理线程继续处理事件，
       要么在同一个线程，要么通过 AsyncContext 分派到容器中的一个资源
       上。

*** 线程安全
    除了startAsync 和 complete 方法，请求和响应对象的实现都不保证线程
    安全。这意味着它们应该仅在请求处理线程范围内使用或应用确保线程安全
    的访问请求和响应对象。

    如果应用使用容器管理对象创建一个线程，例如请求或响应对象，这些对象
    必须在其生命周期内被访问，就像定义在3.12节的“请求对象的生命周期”
    和5.7节的“响应对象的生产周期”。请注意，除了 startAsync 和
    complete 方法，请求和响应对象不是线程安全的。如果这些对象需要多线
    程访问，需要同步这些访问或通过包装器添加线程安全语义，比如，同步化
    调用访问请求属性的方法，或者在线程内为响应对象使用一个局部输出流。

*** 升级处理
    在HTTP/1.1，Upgrade 通用头允许客户端指定其支持和希望使用的其他通信
    协议。如果服务器找到合适的切换协议，那么新的协议将在之后的通信中使
    用。Servle t容器提供了 HTTP 升级机制。不过，Servlet 容器本身不知道
    任何升级协议。协议处理封装在 HttpUpgradeHandler 协议处理器。在容器
    和 HttpUpgradeHandler 协议处理器之间通过字节流进行数据读取或写入。

    当收到一个升级请求，servlet 可以调用 HttpServletRequest.upgrade方
    法启动升级处理。该方法实例化给定的 HttpUpgradeHandler 类，返回的
    HttpUpgradeHandler 实例可以被进一步的定制。应用准备和发送一个合适
    的响应到客户端。退出 servlet service 方法之后，servlet 容器完成所
    有过滤器的处理并标记连接已交给 HttpUpgradeHandler 协议处理器处理。
    然后调用 HttpUpgradeHandler 协议处理器的 init 方法，传入一个
    WebConnection 以允许 HttpUpgradeHandler 协议处理器访问数据流。

    Servlet 过滤器仅处理初始的 HTTP 请求和响应，然后它们将不会再参与到
    后续的通信中。换句话说，一旦请求被升级，它们将不会被调用。
    
    HttpUpgradeHandler 可以使用非阻塞 IO（non blocking IO）消费和生产
    消息。
    
    当处理 HTTP 升级时，开发人员负责线程安全的访问 ServletInputStream
    和 ServletOutputStream。
    
    当升级处理已经完成，将调用 HttpUpgradeHandler.destroy 方法

** 服务的终止
   servlet 容器没必要保持装载的 servlet 持续任何特定的一段时间。一个
   servlet 实例可能会在 servlet 容器内保持活跃（active）持续一段时间
   （以毫秒为单位），servlet容器的寿命可能是几天，几个月，或几年，或者
   是任何之间的时间。

   当 servlet 容器确定 servlet 应该从服务中移除时，将调用 Servlet 接口
   的 destroy 方法以允许 servlet 释放它使用的任何资源和保存任何持久化
   的状态。例如，当想要节省内存资源或它被关闭时，容器可以做这个。

   在 servlet 容器调用 destroy 方法之前，它必须让当前正在执行service
   方法的任何线程完成执行，或者超过了服务器定义的时间限制。

   一旦调用了 servlet 实例的 destroy 方法，容器无法再路由其他请求到该
   servlet 实例了。如果容器需要再次使用该 servlet，它必须用该servlet
   类的一个新的实例。在 destroy 方法完成后，servlet 容器必须释放
   servlet 实例以便被垃圾回收。
* 请求
** 请求对象生命周期
   每个请求对象只在一个 servlet 的 service 方法的作用域内，或过滤器的
   doFilter 方法的作用域内有效，除非该组件启用了异步处理并且调用了请求
   对象的 startAsync 方法。在发生异步处理的情况下，请求对象一直有效，
   直到调用 AsyncContext 的 complete 方法。容器通常会重复利用请求对象，
   以避免创建请求对象而产生的性能开销。开发人员必须注意的是，不建议在
   上述范围之外保持 startAsync 方法还没有被调用的请求对象的引用，因为
   这样可能产生不确定的结果。

   在升级情况下，如上描述仍成立。
* Servlet上下文接口
  ServletContext 接口定义了 servlet 运行在的 Web 应用的视图。容器供应
  商负责提供 servlet 容器的 ServletContext 接口的实现。servlet 可以使
  用 ServletContext 对象记录事件，获取 URL 引用的资源，存取当前上下文
  的其他 servlet 可以访问的属性。

  ServletContext 是 Web 服务器中已知路径的根。例如，servlet 上下文可以
  从 http://www.waylau.com/catalog 找出，/catalog 请求路径称为上下文路
  径，所有以它开头的请求都会被路由到与 ServletContext 相关联的 Web 应
  用。

** ServletContext 接口作用域
   每一个部署到容器的 Web 应用都有一个 ServletContext 接口的实例与之关
   联。在容器分布在多台虚拟机的情况下，每个 JVM 的每个 Web 应用将有一
   个 ServletContext 实例。
   
   如果容器内的 Servlet 没有部署到 Web 应用中，则隐含的作为“默认”
   Web 应用的一部分，并有一个默认的 ServletContext 。在分布式的容器中，
   默认的 ServletContext 是非分布式的且仅存在于一个 JVM 中。

* 响应
** 非阻塞 IO
   非阻塞 IO 仅对在 Servlet 和 Filter（2.3.3.3节定义的，“异步处理”）
   中的异步请求处理和升级处理（2.3.3.5节定义的，“升级处理”）有效。否
   则，当调用 ServletInputStream.setReadListener 或
   ServletOutputStream.setWriteListener 方法时将抛出
   IllegalStateException。

** 结束响应对象
   当响应被关闭时，容器必须立即刷出响应缓冲区中的所有剩余的内容到客户
   端。以下事件表明 servlet 满足了请求且响应对象即将关闭：
   1. servlet 的 service 方法终止。
   2. 响应的 setContentLength 或 setContentLengthLong 方法指定了大于零
      的内容量，且已经写入到响应。
   3. sendError 方法已调用。
   4. sendRedirect 方法已调用。
   5. AsyncContext 的 complete 方法已调用。

** 响应对象的生命周期
   每个响应对象是只有当在 servlet 的 service 方法的范围内或在 filter
   的 doFilter 方法范围内是有效的，除非该组件关联的请求对象已经开启异
   步处理。如果相关的请求已经启动异步处理，那么直到AsyncContext 的
   complete 方法被调用，请求对象一直有效。为了避免响应对象创建的性能开
   销，容器通常回收响应对象。在相关的请求的startAsync 还没有调用时，开
   发人员必须意识到保持到响应对象引用，超出之上描述的范围可能导致不确
   定的行为。
* 过滤器
  Filter（过滤器）是 Java 组件，允许运行过程中改变进入资源的请求和资源
  返回的响应中的有效负载和头信息。

  Java Servlet API 类和方法提供了一种轻量级的框架用于过滤动态和静态内
  容。还描述了如何在 Web 应用配置 filter，以及它们实现的约定和语义。

** 什么是过滤器
   过滤器是一种代码重用的技术，它可以转换 HTTP 请求的内容，响应，及头
   信息。过滤器通常不产生响应或像 servlet 那样对请求作出响应，而是修改
   或调整到资源的请求，修改或调整来自资源的响应。
 
   过滤器可以作用于动态或静态内容。这章说的动态和静态内容指的是 Web 资
   源。

   供开发人员使用的过滤器功能有如下几种类型：
   1. 在执行请求之前访问资源。
   2. 在执行请求之前处理资源的请求。
   3. 用请求对象的自定义版本包装请求对请求的header和数据进行修改。
   4. 用响应对象的自定义版本包装响应对响应的header和数据进行修改。
   5. 拦截资源调用之后的调用。
   6. 作用在一个Servlet，一组Servlet，或静态内容上的零个，一个或多个拦
      截器按指定的顺序执行

** 过滤器生命周期

* 会话
  超文本传输协议（HTTP）被设计为一种无状态协议。为构建有效的 Web 应用，
  使来自一个特定的客户端的请求彼此相关联是必要的。随时间的推移，演变了
  许多会话跟踪机制，这些机制直接使用对程序员而言是困难或麻烦的。

  该规范定义了一个简单的 HttpSession 接口，允许 servlet 容器使用几种方
  法来跟踪用户会话，而不会使应用开发人员陷入到这些方法的细节中。

** 会话跟踪机制
*** Cookie
    通过 HTTP cookie 的会话跟踪是最常用的会话跟踪机制，且所有 servlet
    容器都应该支持。

    容器向客户端发送一个 cookie，客户端后续到服务器的请求都将返回该
    cookie，明确地将请求与会话关联。会话跟踪 cookie 的标准名字必须是
    JSESSIONID。容器也允许通过容器指定的配置自定义会话跟踪cookie的名字。

    所有 servlet 容器必须提供能够配置容器是否标记会话跟踪 cookie 为
    HttpOnly的能力。已建立的配置必须应用到所有上下文中还没有建立特定的
    配置(见 SessionCookieConfig javadoc 获取更多细节)。

    如果 web 应用为其会话跟踪 cookie 配置了一个自定义的名字，则如果会话
    id 编码到 URL 中那么相同的自定义名字也将用于 URI 参数的名字（假如
    URL 重写已开启）。
   
*** SSL会话
    安全套接字层(Secure Sockets Layer)，在 HTTPS 使用的加密技术，有一种
    内置机制允许多个来自客户端的请求被明确识别为同一会话。Servlet容器可
    以很容易地使用该数据来定义会话。
   
*** URL 重写
    URL 重写是会话跟踪的最低标准。当客户端不接受 cookie 时，服务器可使
    用 URL 重写作为会话跟踪的基础。URL 重写涉及添加数据、会话 ID、容器
    解析 URL 路径从而请求与会话相关联。

    会话 ID 必须被编码为 URL 字符串中的一个路径参数。参数的名字必须是
    jsessionid。

*** 会话完整性
    当服务的来自客户端的请求不支持使用 cookie 时，Web 容器必须能够支持
    HTTP 会话。 为了满足这个要求， Web 容器通常支持 URL 重写机制。
** 会话范围
   HttpSession 对象必须被限定在应用（或 servlet 上下文）级别。底层的机
   制，如使用 cookie 建立会话，不同的上下文可以是相同，但所引用的对象，
   包括包括该对象中的属性，决不能在容器上下文之间共享。

   用一个例子来说明该要求： 如果 servlet 使用 RequestDispatcher 来调用
   另一个 Web 应用的 servlet，任何创建的会话和被调用 servlet 所见的必须
   不同于来自调用会话所见的。

   此外，一个上下文的会话在请求进入那个上下文时必须是可恢复的，不管是直
   接访问它们关联的上下文还是在请求目标分派时创建的会话。
** 绑定属性到会话
   servlet 可以按名称绑定对象属性到 HttpSession 实现，任何绑定到会话的
   对象可用于任意其他的 servlet，其属于同一个 ServletContext 且处理属
   于相同会话中的请求。

** 会话超时
   在 HTTP 协议中，当客户端不再处于活动状态时没有显示的终止信号。这意
   味着当客户端不再处于活跃状态时可以使用的唯一机制是超时时间。

   Servlet 容器定义了默认的会话超时时间，且可以通过 HttpSession 接口的
   getMaxInactiveInterval 方法获取。开发人员可以使用HttpSession 接口的
   setMaxInactiveInterval 方法改变超时时间。这些方法的超时时间以秒为单
   位。根据定义，如果超时时间设置为 0 或更小的值，会话将永不过期。会话
   不会失效，直到所有 servlet 使用的会话已经退出其 service 方法。一旦
   会话已失效,新的请求必须不能看到该会话。

** 重要会话语义
*** 多线程问题
    在同一时间多个 servlet 执行请求的线程可能都有到同一会话的活跃访问。
    容器必须确保，以一种线程安全的方式维护表示会话属性的内部数据结构。
    开发人员负责线程安全的访问属性对象本身。这样将防止并发访问
    HttpSession对象内的属性集合，消除了应用程序导致破坏集合的机会。
*** 客户端语义
    由于 cookie 或 SSL 证书通常由 Web 浏览器进程控制，且不与浏览器的任
    意特定窗口关联，从客户端应用程序发起的到 servlet 容器的请求可能在
    同一会话。为了最大的可移植性，开发人员应该假定客户端所有窗口参与同
    一会话。
* 分发请求
  构建 Web 应用时，把请求转发给另一个 servlet 处理、或在请求中包含另一
  个 servlet 的输出通常是很有用的。RequestDispatcher 接口提供了一种机
  制来实现这种功能。

  当请求启用异步处理时，AsyncContext 允许用户将这个请求转发到servlet
  容器。

* Web 应用
  Web 应用是一个 servlets,HTML 页面,类,和其他资源的集合，用于一个在
  Web 服务器的完成的应用。Web 应用可以捆绑和运行来自多个供应商的在多个
  容器。

** Web 服务器中的 Web 应用
   在 Web 服务器中 Web 应用程序的根目录是一个特定的路径。例如，一个
   catalog应用，可以位于 http://www.mycorp.com/catalog。以这个前缀开始
   的所有请求将被路由到代表 catalog 应用的 ServletContext 环境中。
   
   servlet 容器能够制定Web应用程序自动生成的规则。例如，一个~user/映射
   可用于映射到一个基于/home /user/public_html/ 的 Web 应用。

   默认情况下，在任何时候一个 Web 应用程序的实例必须运行在一个虚拟机
   （VM）中。如果应用程序通过其部署描述文件标记为“分布式”的，那么可
   以覆盖此行为。标记为分布式的应用程序必须遵守比普通的 Web 应用程序更
   严格的规则。本规范中陈述了这些规则。

** 与 ServletContext 的关系
   servlet 容器必须强制 Web 应用程序和 ServletContext 之间一对一对应的
   关系。ServletContext 对象提供了一个 servlet 和它的应用程序视图。

** Web 应用部署
   当一个 Web 应用程序部署到容器中，在 Web 应用程序开始处理客户端请求
   之前，必须按照下述步骤顺序执行。
   1. 实例化部署描述文件中<listener>元素标识的每个事件监听器的一个实例。
   2. 对于已实例化的实现了 ServletContextListener 接口的监听器实例，调
      用 contextInitialized() 方法。
   3. 实例化部署描述文件中<filter>元素标识的每个过滤器的一个实例，并调
      用每个过滤器实例的init()方法。
   4. 包含<load-on-startup>元素的<servlet>元素，根据 load-on-startup
      元素值定义的顺序为每个 servlet 实例化一个实例，并调用每个
      servlet 实例的 init() 方法。

** 包含 web.xml 部署描述符
   如果 Web 应用不包含任何 servlet、过滤器、或监听器组件或使用注解声明
   相同的，那么可以不需要 web.xml 文件。换句话说，只包含静态文件或 JSP
   页面的应用程序并不需要一个 web.xml 的存在。
* 应用生命周期事件
** 监听器实例和线程
   容器需要在开始执行进入应用的第一个请求之前完成 Web 应用中的监听器类
   的实例化。容器必须保持到每一个监听器的引用直到为 Web 应用最后一个请
   求提供服务。

   ServletContext 和 HttpSession 对象的属性改变可能会同时发生。不要求
   容器同步到属性监听器类产生的通知。维护状态的监听器类负责数据的完整
   性且应明确处理这种情况。
* 映射请求到 Servlet
* 安全
