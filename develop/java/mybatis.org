* overview
  Mybatis作为Java常用的访问数据库层的框架，其工作主要交给创建的
  Sqlsession对象完成。它支持定制化 SQL、存储过程以及高级映射。MyBatis
  避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

  MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。
  MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。
  MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的
  POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。

* Mybatis核心类
** SqlSessionFactory
   每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。
   SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而
   SqlSessionFactoryBuilder 则可以从 XML 配置文件或通过Java的方式构建
   出 SqlSessionFactory 的实例。SqlSessionFactory 一旦被创建就应该在应
   用的运行期间一直存在，建议使用单例模式或者静态单例模式。

** SqlSession
   SqlSession是一个接口，它有2个实现类，分别是DefaultSqlSession(默认使
   用)以及SqlSessionManager。SqlSession通过内部存放的执行器（Executor）
   来对数据进行CRUD。此外SqlSession不是线程安全的，因为每一次操作完数
   据库后都要调用close对其进行关闭，官方建议通过try-finally来保证总是
   关闭SqlSession。

** Executor
   Executor（执行器）接口有两个实现类，其中BaseExecutor有三个继承类分
   别是BatchExecutor（重用语句并执行批量更新），ReuseExecutor（重用预
   处理语句prepared statements），SimpleExecutor（普通的执行器）。以上
   三个就是主要的Executor。通过下图可以看到Mybatis在Executor的设计上面
   使用了装饰者模式，我们可以用CachingExecutor来装饰前面的三个执行器目
   的就是用来实现缓存。

** MappedStatement
   MappedStatement就是用来存放我们SQL映射文件中的信息包括sql语句，输入
   参数，输出参数等等。一个SQL节点对应一个MappedStatement对象。

* Mybatis的原理及其工作流程
  Mybatis加载流程
  1. spring加载mybatis
  2. 加载配置文件到内存
  3. 加载mapper文件到内存
  4. 生产SqlsessionFactory


  Mybatis执行流程
  1. 从SqlsessionFactory获取Sqlsession
  4. 封装请求参数
  5. 预编译sql
  6. 执行sql
  7. 封装返回参数

* 事务管理机制
  MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）
  1. JDBC - 直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接
     来管理事务范围。
  2. MANAGED - 让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下
     文）。

  SqlSessionFactory mybatis通过这个核心类来管理session，session进行提交
  和回滚。

** 常见坑点
   使用事务注解@Transactional 之前，应该先了解它的相关属性，避免在实际
   项目中踩中各种各样的坑点。

**** 常见坑点1：遇到非检测异常时，事务不开启，也无法回滚。
     原因分析：因为Spring的默认的事务规则是遇到运行异常
     （RuntimeException）和程序错误（Error）才会回滚。如果想针对非检测异
     常进行事务回滚，可以在@Transactional 注解里使用rollbackFor 属性明确
     指定异常。

     @Transactional(rollbackFor = Exception.class)

**** 常见坑点2： 在业务层捕捉异常后，发现事务不生效。
     在业务层手工捕捉并处理了异常，你都把异常“吃”掉了，Spring自然不
     知道这里有错，更不会主动去回滚数据。

**** 推荐做法：在业务层统一抛出异常，然后在控制层统一处理。

** 参考
   - https://www.jianshu.com/p/380a9d980ca5
   - https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html

* 连接池管理机制
* 缓存机制
** 参考
   - https://blog.csdn.net/bjweimengshu/article/details/79988252
* SQL语句的配置方式
* spring-boot-mybatis-starter
  将spring-boot与mybatis整合优化，方便使用。
** 取消spring-mybatis.xml配置
  1. 自动检测已存在的Datasource

     之前，需要在spring-mybatis.xml中配置datasource的Bean，现在只需要
     在application.yml中配置到spring.datasource节点下就可以。因为
     mybatis-spring-boot支持自动检测已存在的Datasource。
  2. 将创建并注册SqlSessionFactoryBean实例，并传入Datasource。

     在mybatis中，sqlsession可以有SqlSessionFactory创建；而在
     mybatis-spring中则需要SqlSessionFactoryBean来创建，并传入
     datasource。
  3. 将从SqlSessionFactoryBean中创建并注册SqlSessionTemplate

     SqlSessionTemplate是SqlSession的实现类，较SqlSession的默认实现类
     DefaultSqlSession来说，是线程安全的。
  4. 自动扫描mappers，将其关联到SqlSessionTemplate，并将mappers注册到
     spring容器中，以便注入到我们的beans中。

     默认情况下，mybatis-spring-boot将搜索被@Mapper注释标注的mappers。

** 参考
  - https://blog.csdn.net/gongsunjinqian/article/details/52710557
  - https://gavinlee1.github.io/2017/03/17/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA-SpringBoot-%E9%9B%86%E6%88%90-Mybatis/

* 参考
  Ref:
  - https://blog.csdn.net/qq_27886997/article/details/78073379
  - https://blog.csdn.net/qq_27384769/article/details/79369843
  - https://blog.csdn.net/qq_41426442/article/details/79663421
