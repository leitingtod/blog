* 分布式系统
  面临的挑战：
  1. 分布式系统的管理
  2. 进程间跨机通信
  3. 事务
  4. 部署问题（扩容缩容）
  5. 日志服务
  6. 开发效率：分布式系统除了要实现业务需求的功能，还需要增加额外的很
     多非功能需求。这些非功能需求会让你的代码更加复杂。若没有很好的工
     具，会让开发效率严重下降。

** 分布式系统设计策略
   1. 心跳检测（如何检测还活着）
   2. 高可用（主备、互备、集群）
   3. 容错处理
   4. 重试机制
   5. 负载均衡
** 分布式系统设计实践
   - 全局ID生成
   - Hash取模分配
   - 路由表
   - 一致性Hash
   - 数据拆分 
     
** 理论
*** CAP
*** 一致性解决算法
    - Paxos
    - Raft
    - 2PC
    - 3PC
*** 解决网络拥塞或瞬断的情况出现的双主问题
*** Quorum NWR, MVCC解决分布式存储的一致性问题
*** Gossip是一种去中心化、容错且最终一致性的算法

* 分布式计算
* 分布式存储
* 分布式缓存
* 分布式数据库
* 分布式事务
  分布式事务就是指事务的资源分别位于不同的分布式系统的不同节点之上的事
  务。

*** 分布式事务产生的原因
    1. 数据库分库分表

       在单库单表场景下，当业务数据量达到单库单表的极限时，就需要考虑
       分库分表，将之前的单库单表拆分成多库多表。

       分库分表之后，原来在单个数据库上的事务操作，可能就变成跨多个数
       据库的操作，此时就需要使用分布式事务。

    2. 业务服务化
       
       业务服务化即业务按照面向服务（SOA）的架构拆分整个网站系统；

       比如互联网金融网站SOA拆分，分离出交易系统、账务系统、清算系统等，
       交易系统负责交易管理和记录交易明细，账务系统负责维护用户余额，
       所有的业务操作都以服务的方式对外发布。

       一笔金融交易操作需要同时记录交易明细和完成用户余额的转账，此时
       需要分别调用交易系统的交易明细服务和账务系统的用户余额服务，这
       种跨应用、跨服务的操作需要使用分布式事务才能保证金融数据的一致
       性。
       
*** 分布式事务原理
**** ACID
**** 2PC
     两阶段提交协议（Two Phase Commitment Protocol）是分布式事务的基础
     协议。

     在此协议中，一个事务协调器（TM, transaction manager）协调多个资源
     管理器（RM, resource manager）的活动；在一阶段所有资源管理器（RM）
     向事务管理器（TM）汇报自身活动状态，在第二阶段事务管理器（TM）根
     据各资源管理器（RM）汇报的状态，来决定各RM是执行提交操作还是回滚
     操作。

**** 2PC应用之XA
     XA是X/Open组织提出的，定义了事务管理器与资源管理器之间通信的接口
     协议；XA协议由数据库实现，目前支持XA协议的数据库有Oracle、MySql、
     BD2等。

**** 2PC应用之TCC
      TCC是Try、Confirm、Cancel 3个操作的缩写；

      Try操作对应2PC的一阶段Prepare，Confirm对应2PC的二阶段commit，
      Cancel对应2PC的二阶段rollback；

      这3个操作均有用户编码实现；

      TCC三个操作描述：
      1. Try: 检测、预留资源;
      2. Confirm: 业务系统执行提交；默认Confirm阶段是不会出错的，只要
         TRY成功，CONFIRM一定成功；
      3. Cancel: 业务取消，预留资源释放;

      用户通编码实现TCC并发布成服务，这个TCC服务就可以作为资源参与到分
      布式事务中；事务管理器分2阶段协调所有的TCC资源，使得所有TCC资源
      状态最终都是一致，要么全部提交，要么全部回滚。

      TCC自编码的特性决定TCC资源管理器可以跨DB、跨应用实现资源管理，将
      对不同的DB访问、不同的业务操作通过编码方式转换一个原子操作，解决
      了复杂业务场景下的事务问题。

      同时TCC的每一个操作对于DB来讲都是一个本地DB事务，操作结束则本地
      DB事务结束，数据库的资源也就被释放；这就规避了数据库层面的2PC对
      资源占用导致的性能低下问题。

**** 柔性事务
     单数据库事务完全遵循ACID规范，属于刚性事务，分布式事务要完全遵循
     ACID规范比较困难, 分布式事务属于柔性事务，满足BASE理论；

     BASE描述： BA（Basic Availability 基本业务可用性）、S（Soft state
     柔性状态）、E（Eventual consistency 最终一致性）；

     柔性事务对ACID的支持：
     1. 原子性： 严格遵循；
     2. 一致性： 事务完成后的一致性严格遵循，事务中的一致性可适当放宽；
     3. 隔离性： 并行事务间不可影响；事务中间结果可见性允许安全放宽；
     4. 持久性： 严格遵循；

***** 柔性事务的分类
      柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型。

      1. 两阶段型
      
         就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS，这是分布式
         环境下事务处理的典型模式。

      2. 补偿型

         TCC型事务（Try/Confirm/Cancel）可以归为补偿型；TCC思路是:尽
         早释放锁；在Try成功的情况下，如果事务要回滚，Cancel将作为一个
         补偿机制，回滚Try操作。

         TCC各操作事务本地化，且尽早提交 (放弃两阶段约束)；当全局事务
         要求回滚时，通过另一个本地事务实现“补偿”行为。

         TCC是将资源层的两阶段提交协议转换到业务层，成为业务模型中的一
         部分。

      3. 异步确保型

         将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争
         用；比如消息事务机制。

      4. 最大努力通知型

         通过通知服务器(消息通知)进行，允许失败，有补充机制。
      
**** 参考
     - https://yq.aliyun.com/articles/608863

* 分布式锁
  分布式服务中，如果各个服务节点需要竞争资源，不能像单机多线程应用一样
  使用线程锁，需要由一套分布式锁机制保证节点对资源的访问。通常分布式锁
  以单独的服务方式实现，目前比较常用的分布式锁实现有三种：zookeeper实
  现、redis实现和memcache实现。后两者本质上相同。

** Zookeeper
   基于zookeeper临时顺序节点实现分布式锁，其大致思想为：
   1. 每个客户端对某个功能加锁时，在Zookeeper上的与该功能对应的指定节
      点的目录下，生成一个唯一的临时顺序节点
   2. 所有临时顺序节点中序号最小的，即为当前持有锁的节点
   3. 释放锁时，将自己注册的这个临时顺序节点删除即可

   在客户端监听注册节点目录的变化，当发生节点删除时通知各个客户端检查
   是否自己持有了锁。

   如果集群规模很大，这样做可能引起羊群效应，此时可以优化为客户端监听
   注册节点目录下，比自己节点小的节点变化。当比自己小的节点都删除了，
   那么自己就持有了锁。

   优缺点：
   1. 锁安全性高，zookeeper数据不易丢失
   2. 性能开销比较高。因为其需要动态产生、删除临时顺序节点，还需要监听
      节点变化来实现锁功能。

*** 参考
    - https://blog.csdn.net/xiaoliuliu2050/article/details/51226237

** redis
   利用redis中的set命令来实现分布式锁: SET KEY VALUE [EX seconds] [PX
   milliseconds] [NX|XX]。

   大致思想是：
   1. SET lock currentTime+expireTime EX 600 NX，使用set设置lock值，并
      设置过期时间为600秒，如果成功，则获取锁；
   2. 获取锁后，如果该节点掉线，则到过期时间ock值自动失效；
   3. 释放锁时，使用del删除lock键值；

   使用redis单机来做分布式锁服务，可能会出现单点问题，导致服务可用性差，
   因此在服务稳定性要求高的场合，官方建议使用redis集群（例如5台，成功
   请求锁超过3台就认为获取锁），来实现redis分布式锁。详见RedLock。


   优缺点:
   1. 性能高，redis可持久化，也能保证数据不易丢失；redis集群方式提高稳定性。
   3. 使用redis主从切换时可能丢失部分数据。

** memcached
   利用memcached的add函数实现分布式锁。
   
   add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存
   储的值以最后的set的线程为准。而add的话则相反，add会添加第一个到达的
   值，并返回true，后续的添加则都会返回false。利用该点即可很轻松地实现
   分布式锁。

   优缺点:
   1. 因为是全内存存储，并发高效。
   2. memcached采用列入LRU置换策略，所以如果内存不够，可能导致缓存中的
      锁信息丢失。
   3. memcached无法持久化，一旦重启，将导致信息丢失。
