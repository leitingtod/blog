* SQL
** core operation
  select, create, drop, alter, insert, delete, update, grant, revoke
** table
*** create table
    create table 表名 (列名 type [列级完整性约束] [, 列名 type [列级完整性约束] ...);
*** alter table
**** add column
     alter table 表名 add 列名 type [列级完整性约束];

**** modify column
     *只能修改类型吗？能修改完整性约束吗？或是各个产品实现各不相同？*

     alter table 表名 modify 列名 type;
**** del column
     *不能删除列，只能增加列，因删除列可能会破坏已有数据*

     alter table 表名 drop 列名 [列级完整性约束];
*** drop table
    drop table 表名
** record
*** select
    select [ALL|DISTINCT] *|列名 from 基本表名|视图
    [where 条件表达式]
    [group by 列名1 [having 内部函数表达式]]
    [order by 列名2 {ASC, DESC} ];

**** 简单查询
     select SA, SD from S;

**** 简单查询，去除重复的元组
     select DISTINCE SA, SD from S;

**** 连续范围查询
     select SA from S where SA between 20 and 22;

**** 离散范围查询
     select * from S where SD in ('MA', 'CS');

**** 模糊查询
     _ 匹配单个字符, % 匹配任何字符（各个产品实现可能有所不同）

     select * from S where SN like '%清%';
     select * from S where SN like '_清%';

**** 连接查询
     SQL中没有专门的join命令，需要用where子句来达到连接的目的。

***** 简单连接查询
      select S.SN from S, SC where S.SN = SC.SN and SC.CN = 'C1';

***** 多表连接查询
      select S.SN, C.CN, SC.G from S, C, SC where S.SN = SC.SN and C.CN = SC.CN;

***** 单表连接
      select A.CN, B.CN from C A, C B where A.PCN = B.CN;

***** 外连接
      select S.SN, SC.CN, SC.G from S, SC where S.SN = SC.SN (*);

**** 嵌套查询
     - 查询由内向外处理
     - 允许多层嵌套
     - 常用 IN， 若子查询结果为单值，可使用 =, < 等比较运算符

**** 使用存在量词 EXIST, NOT EXIST 的查询

**** 库函数
     count 统计一列中非空值的个数
     count(*) 计算记录个数
     sum 对一列求和
     avg 对一列求平均值
     max 对一列求最大值
     min 对一列求最小值
*** insert
    insert into 表名 [列名 [, 列名] ...] values (value [, value] ...);

    - 当在INTO后面仅指定部分属性列时，插入记录后其它列的值为空值；
    - 如果INTO后面没有指定属性列，则必须按表列的定义次序为每个列指定一个值；
    - 具有NOT NULL属性的列，必须指定值

    insert into S (SN, CN) values ('S1', 'C1');
*** update
    update 表名 set 列名=表达式 [, 列名=表达式] ... [where 条件];

    - 当省略WHERE子句时，修改表中所有记录，否则仅修改满足条件的记录；
    - 条件也可以使用子查询

    update S set SA=SA+1;

*** delete
    delete from 表名 [where 条件];

    - 只能删除表记录，删除表结构用 drop table
    - 为物理删除命令
    - 无条件时，删除全部记录

    delete from SC where G < 60;

*** index
    索引分聚簇索引(CLUSTER)、唯一索引(UNIQUE)。

    改变记录的物理存储顺序使之与索引项值的排列顺序相同，称为聚簇索引。

**** create index
     create [UNIQUE] [CLUSTER] index 索引名 on 表名 (列名 {ASC, DESC} [, 列名 {ASC, DESC}]);

**** drop index
     drop index 索引名

** view
   - 视图是从一个或几个基本表（或视图）导出的表（用户外模式是由若干基本表和/或若
     干视图构成的）。
   - 视图是一个虚表，只存储视图的定义，数据存在所基于的基本表中。
   - 视图定义后就可象基本表一样来使用
     - 可创建、删除视图
     - 可用来定义新的视图
     - 可在视图上查询（SELECT）
     - 可更新（INSERT， DELETE， UPDATE）视图，但受限制

*** create view
    create view 视图名 [(列名 [, 列名] ...)] as 子查询 [with check-option];

    - 组成视图的属性列名，要么全部写出，要么全部省略，省略时，隐含视图的属性列同
      子查询的目标列。当SELECT语句中有库函数、或字段表达式、或多表连接有同名字段
      时，则视图中必须指定字段名
    - 视图中字段名可以和基本表中的字段名不同
    - 没有修改视图的方法，要实现此功能，唯一的途径是先 删除，再重建。
    - 视图的子查询可以基于一个或多个基本表或/和视图上

    create view CS_S as select SN, SA from S where SD='CS';
    create view S_G(SN, GAVG) as select SN, avg(G) from SC group by SN;
*** drop view
    - 删除基本表或视图后，由被删除的基本表或视图导出的视图仍然存在，但已无法使用，
      需另行删除

    drop view 视图名
*** 视图查询
    执行过程： 从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，
    转换成等价的对基本表的查询，最后在基本表上执行修改后的查询，这一转换称为视图
    消解。

    *注意* ： 当视图中的字段对应的是一个库函数或字段表达式时，有些系统 转换后的查询可能会
    不正确
*** 视图上的更新（INSERT， DELETE， UPDATE）
    执行过程： 将对视图的更新语句转化为对相应的基本表的更新语句，然后执行。为防止更新基本表
    中不属于本视图的数据，可在视图定义时加上WITH CHECK OPTION子句。
    *注意* ：
    - 不是所有的视图更新都可正确转化为对基本表的更新语句
    - 有些视图是可更新的, 有些视图是不可更新的
    - 肯定可以更新的视图是行列子集视图(从单个表导出，且只是去掉了基本表的某些行
      和某些列并保留了码)
    - 处理方式：只有从单个表导出的视图才允许更新操作，且作一系列的限制
    - 从概念上分清不可更新视图和不允许更新视图。
*** 视图的优点
    1. 能够简化用户的操作
    2. 用户能以不同的方式对待同一数据，方便灵活
    3. 提供一定程度的逻辑独立性
    4. 有利于安全保密

** 数据控制功能
   数据控制功能包括事物管理功能和数据保护功能，即数据的安全性、完整性、事务控制、
   并发控制和恢复功能。

*** 授权
    grant 权限 [, 权限] ... [on 对象类型 对象名] to 用户名 [, 用户名] ... [with grant-option];
    revoke
* 事务
  为保证数据的一致性，大型数据库系统一般都提供若干策略：
  - 删除主表（被参照表）中的数据时
    1. 自动删除参照表中的相应数据；
    2. 检查参照表中是否有数据参照，若有则拒绝删除。
  - 向参照表中插入数据时
    1. 检查所有被参照表中是否有被参照的信息，若没有则拒
       绝插入
  - 修改主表中的被参照字段
    1. 检查参照表中是否有数据参照，若有则拒绝修改。
** 并发控制
   事务是并发控制的基本单位，保证事务的ACID特性是事务处理的主要任务。
*** 并发可能带来的一致性问题
    1. 丢失修改

       当两个事务读入同一个数据，并同时修改此数据，一个事务提交的结果覆盖了另一个事务提交的结果，导致修改丢失。此
       种情形的纠正方式是当结果修改后，另一事务能立即观察到此修改。

    2. 不可重复读

       当一个事务修改了一个数据后，另一事务无法再现前一次读取的数据结果。包括三种情况：
       - 数据结果已改变
       - 数据被删除或不存在
       - 数据结果记录增多

    3. 读脏数据

       一个事务提交结果后，被另一事务读取，当前者因故又取消了提交，导致后者读到的数据因取消而变成了脏数据。

*** 并发控制的手段
    主要有封锁、时间戳、乐观控制法。

**** 封锁
     锁有两种类型：
     1. 排它锁(Exclusive Locks，也叫写锁)

	当一个事务对数据A加上写锁后，则只允许此事务读写数据A，其他任何事务不能对
	A加任何类型的锁，直到事务完成并释放A上的写锁。

     2. 共享锁(Share Locks，也叫读锁)

	当一个事务对数据A加上读锁后，则只允许此事务读数据A，不能修改数据A，其他
	事务只能对A加读锁，而不能加写锁，直到此事务完成并释放A上的读锁。

     活锁：当多个事务请求封锁同一数据时，按请求封锁的先后次序对事务排除，避免了
     一个事务因总是请求不到锁而得不到执行。

     死锁：当两个事务互相请求对方封锁的数据后，导致互相等等，永远无法执行的问题。
     解决方法：
     1. 预防处理
	1. 一次封锁法：每个事务必须一次将所有要使用的数据全部加锁（问题：1. 扩大
	   了封锁的范围，降低了系统并发度；2. 数据是变化的，很难事先精确确定每个
	   事务所要封锁的数据，为此只能扩大封锁范围，进一步降低了并发度）
	2. 顺序封锁法：预先对数据规定一个封锁顺序，所有事务都按这个顺序进行封锁
	   （问题：1.封锁的数据极多，且随着数据的插入、删除，维护这样的资源封锁
	   顺序非常困难；2. 很难事先确定一个事务要封锁哪些对象，也就不所谓顺序）

     2. 事后处理
	1. 超时法：事务的等待时间超过了规定的时限，就认为发生了死锁（不足：1. 事
	   务因非死锁问题导致超时，系统会误认为发生了死锁；2.时限设置矿长，死锁
	   发生后不能及时发现）

	2. 等待图法



**** 并发调度的可串行性
     多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务的
     结果相同，则称这种调度策略为可串行化调度。

* 数据库设计
  需求分析、概念设计、逻辑设计、物理设计
** 需求分析
** 概念设计
   概念结构设计的第一步是利用抽象机制对需求分析阶段收集的数据进行分类、组织（聚
   集），形成实体、实体的属性，标识实体的码，确定实体之间的联系(1:1， 1:m， n:m)，
   设计分E-R图。
** 逻辑设计
   逻辑结构分三步进行：
   1. 将概念结构转换成一般的关系、层次、网状模型
   2. 将转换来的关系、层次、网状模型向特定的DBMS支持下的数据模型转换
   3. 对数据模型进行优化
** 物理设计
* 常见的数据库优化策略
  1. 选取最合适的字段属性，尽量减小表的大小
  2. 使用Join代替子查询
  3. 使用联合代替手动创建的临时表
  4. 使用索引
     1. 不要对含有大量重复数据的字段建立索引
     2. 尽量在那些将用于join, where, order by中的字段建立索引
  5. 优化查询语句
     1. 最好在类型相同的字段间进行比较操作
     2. 在建有索引的字段上尽量不要使用函数进行操作


  数据库访问优化漏斗法则：
  1. 减少磁盘访问（减少数据访问(1-1000)，返回更少的数据(1-100)）
  2. 减少网络传输（返回更少的数据，减少交互次数(1-20)）
  3. 减少CPU开销和内存开销（减少服务器CPU开销(1-5)）
  4. 增加资源（利用更多资源1-10）
* mysql千万级大数据SQL查询优化
** 常见措施
   1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
   2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0
   3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。
   4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20
   5.in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3
   6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。
   7. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num
   8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2
   9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id应改为:
   select id from t where name like ‘abc%’

   10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
   11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
   12.不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0
   这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：
   create table #t(…)

   13.很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)
   用下面的语句替换：
   select num from a where exists(select 1 from b where num=a.num)

   14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。
   15. 索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。
   16. 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。
   17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
   18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
   19.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
   20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
   21.避免频繁创建和删除临时表，以减少系统表资源的消耗。
   22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。
   23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
   24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
   25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
   26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。
   27. 与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。
   28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。
   29.尽量避免大事务操作，提高系统并发能力。
   30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
*** 参考
    - https://blog.csdn.net/u014421556/article/details/52063904
    - https://blog.csdn.net/qq_23211905/article/details/73473393

** like 模糊查询及效率
   filed 已建立索引，百万数据量

   select colun-name from table-name where field like "%keyword%"; 此
   查询未用到索引，且是全表搜索，在数据量大的时候可想而知

   select colun-name from table-name where field like "keyword%";而此
   名则会用到索引，效率大大提高

   这个时候，我们可以考虑用其他的方法，充分利用索引，先查出数据再匹配。
   1. LOCATE（’substr’,str,pos）方法，如SELECT LOCATE(‘bar’,foobarbar,5);
      
** 关于 mysql 中 find_in_set 与 like 查询的一些思考
** mysql之explain详解（分析索引的最佳使用）
   EXPLAIN SELECT * from user_info WHERE id < 300;
* 索引
** overview
   索引是在存储引擎中实现的，因此每种存储引擎的索引都不一定完全相同，
   并且每种存储引擎也不一定支持所有索引类型。

   根据存储引擎定义每个表的最大索引数和最大索引长度。所有存储引擎支持
   每个表至少16个索引，总索引长度至少为256字节。

   大多数存储引擎有更高的限制。MYSQL中索引的存储类型有两种：BTREE和
   HASH，具体和表的存储引擎相关；

   MYISAM和InnoDB存储引擎只支持BTREE索引；MEMORY和HEAP存储引擎可以支持
   HASH和BTREE索引

   索引的优点：
   1. 通过创建唯一索引，保证数据库表每行数据的唯一性
   2. 大大加快数据查询速度
   3. 在使用分组和排序进行数据查询时，可以显著减少查询中分组和排序的时间

   索引的缺点：
   1. 维护索引需要耗费数据库资源
   2. 索引需要占用磁盘空间，索引文件可能比数据文件更快达到最大文件尺寸
   3. 当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响


   索引的分类
   1. 普通索引和唯一索引
      
      主键索引是一种特殊的唯一索引，不允许有空值

   2. 单列索引和复合索引

      单列索引只包含单个列

      复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时
      的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合

   3. 全文索引

      全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在
      这些索引列中插入重复值和空值。全文索引可以在

      CHAR、VARCHAR、TEXT类型列上创建。MYSQL只有MYISAM存储引擎支持全文
      索引

   4. 空间索引

      空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型
      有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。

      MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语
      法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索
      引只能在存储引擎为MYISAM的表中创建

** mysql索引是一个非常好用的检索优化手段，但是用不好，也会影响数据库的查询速度
   1. like查询中，使用%, %在条件之前。如果通配符%在条件前面，mysql首先
      是扫描全表，然后再去匹配，所以索引也就失效了

      那什么情况下%在条件前面索引会有效呢？只有在这种情况时，即查询建
      立了索引的列的情况下，但是这种情况下跟是否使用%没有关系的，因为
      查询索引列的时候本身就用到了索引

   2. 如果一个字符串类型的字段，查询时，传递的是一个整形数，也会全表扫描
      explain select * from table-name where name="12345" \G;
      explain select * from table-name where name=12345 \G;

** 参考
   - http://blog.jobbole.com/113142/
   - https://blog.csdn.net/l1028386804/article/details/46591673

* 表变量和临时表
  https://blog.csdn.net/leamonjxl/article/details/6602716

* MySQL游标
** overview
   MySQL的游标（cursor）是一个重要的概念，通过查找资料与自己的理解，主
   要得出以下几点关于自己的理解。

   有数据缓冲的思想：游标的设计是一种数据缓冲区的思想，用来存放SQL语句
   执行的结果。 先有数据基础：游标是在先从数据表中检索出数据之后才能继
   续灵活操作的技术。 类似于指针：游标类似于指向数据结构堆栈中的指针，
   用来pop出所指向的数据，并且只能每次取一个。

   针对游标的优缺点，我总结游标的使用场景，主要用在循环处理、存储过程、
   函数中使用，用来查询结果集，

   #+begin_src mysql
   # define a cursor
   declare mycursor for select * from table-name;

   # open cursor
   open mycursor
   # use cursor
   declare var1 datatype
   fetch next|prior|first|last from mycursor into var1
   # close
   close mycursor
   # release
   deallocate mycursor
   #+end_src
*** 参考
    - https://www.2cto.com/database/201712/703523.html

* 存储过程
** overview
  存储过程Procedure是一组为了完成特定功能的SQL语句集合，经编译后存储在
  数据库中，用户通过指定存储过程的名称并给出参数来执行。

  存储过程中可以包含逻辑控制语句和数据操纵语句，它可以接受参数、输出参
  数、返回单个或多个结果集以及返回值。

  由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所
  以存储过程运行要比单个的SQL语句块要快。同时由于在调用时只需用提供存
  储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网
  络负担。


  存储过程的优点:
  1. 存储过程允许标准组件式编程

     存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过
     程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应
     用程序源代码却毫无影响，从而极大的提高了程序的可移植性。

  2. 存储过程能够实现较快的执行速度

     如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程
     要比批处理的执行速度快得多。因为存储过程是预编译的，在首次运行一
     个存储过程时，查询优化器对其进行分析、优化，并给出最终被存在系统
     表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所
     以速度就要慢一些。

  3. 存储过程减轻网络流量

     对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被
     组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的
     只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了
     网络负载。

  4. 存储过程可被作为一种安全机制来充分利用

     系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对
     某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。


  系统存储过程是系统创建的存储过程，目的在于能够方便的从系统表中查询信
  息或完成与更新数据库表相关的管理任务或其他的系统管理任务。

  系统存储过程主要存储在master数据库中，以“sp”下划线开头的存储过程。
  尽管这些系统存储过程在master数据库中，但我们在其他数据库还是可以调用
  系统存储过程。有一些系统存储过程会在创建新的数据库的时候被自动创建在
  当前数据库中。

  自定义存储过程:
  #+begin_src sql
  --创建存储过程
  if (exists (select * from sys.objects where name = 'proc_get_student'))
      drop proc proc_get_student
  go
    create proc proc_get_student
  as
    select * from student;

  --调用、执行存储过程
  exec proc_get_student;

  #+end_src
*** 参考
    - https://www.cnblogs.com/xiangzhong/p/5038338.html

** 存储过程中的 SET NOCOUNT ON 和SET NOCOUNT OFF
   当 SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的
  行数）。

  当 SET NOCOUNT 为 OFF 时，返回计数。 如果存储过程中包含的一些语句并
  不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高
  性能

* MySQL 事务
** 隔离级别
   |------------------------------+--------------------+----------------------------------+----------------------|
   | 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
   |------------------------------+--------------------+----------------------------------+----------------------|
   | 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
   | 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
   | 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
   | 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |
   |------------------------------+--------------------+----------------------------------+----------------------|

   + 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中
     未提交事务修改的数据

   + 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数
     据库默认都是该级别 (不重复读)

   + 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开
     始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重
     复读，但是还存在幻象读

   + 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，
     读写相互都会阻塞


   1. 脏读: 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而
      这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，
      然后使用了这个数据。

   2. 不可重复读: 是指在一个事务内，多次读同一数据。在这个事务还没有结
      束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读
      数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可
      能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，
      因此称为是不可重复读。

   3. 可重复读

   4. 幻读: 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的
      全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表
      中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中
      还有没有修改的数据行，就好象发生了幻觉一样。
