* SQL
** core operation
  select
  create, drop, alter
  insert, delete, update
  grant, revoke
** table
*** create table
    create table 表名 (列名 type [列级完整性约束] [, 列名 type [列级完整性约束] ...);
*** alter table
**** add column
     alter table 表名 add 列名 type [列级完整性约束];

**** modify column
     *只能修改类型吗？能修改完整性约束吗？或是各个产品实现各不相同？*

     alter table 表名 modify 列名 type;
**** del column
     *不能删除列，只能增加列，因删除列可能会破坏已有数据*

     alter table 表名 drop 列名 [列级完整性约束];
*** drop table
    drop table 表名
** record
*** select
    select [ALL|DISTINCT] *|列名 from 基本表名|视图
    [where 条件表达式]
    [group by 列名1 [having 内部函数表达式]]
    [order by 列名2 {ASC, DESC} ];

**** 简单查询
     select SA, SD from S;

**** 简单查询，去除重复的元组
     select DISTINCE SA, SD from S;

**** 连续范围查询
     select SA from S where SA between 20 and 22;

**** 离散范围查询
     select * from S where SD in ('MA', 'CS');

**** 模糊查询
     _ 匹配单个字符, % 匹配任何字符（各个产品实现可能有所不同）

     select * from S where SN like '%清%';
     select * from S where SN like '_清%';

**** 连接查询
     SQL中没有专门的join命令，需要用where子句来达到连接的目的。

***** 简单连接查询
      select S.SN from S, SC where S.SN = SC.SN and SC.CN = 'C1';

***** 多表连接查询
      select S.SN, C.CN, SC.G from S, C, SC where S.SN = SC.SN and C.CN = SC.CN;

***** 单表连接
      select A.CN, B.CN from C A, C B where A.PCN = B.CN;

***** 外连接
      select S.SN, SC.CN, SC.G from S, SC where S.SN = SC.SN (*);

**** 嵌套查询
     - 查询由内向外处理
     - 允许多层嵌套
     - 常用 IN， 若子查询结果为单值，可使用 =, < 等比较运算符

**** 使用存在量词 EXIST, NOT EXIST 的查询

**** 库函数
     count 统计一列中非空值的个数
     count(*) 计算记录个数
     sum 对一列求和
     avg 对一列求平均值
     max 对一列求最大值
     min 对一列求最小值
*** insert
    insert into 表名 [列名 [, 列名] ...] values (value [, value] ...);

    - 当在INTO后面仅指定部分属性列时，插入记录后其它列的值为空值；
    - 如果INTO后面没有指定属性列，则必须按表列的定义次序为每个列指定一个值；
    - 具有NOT NULL属性的列，必须指定值

    insert into S (SN, CN) values ('S1', 'C1');
*** update
    update 表名 set 列名=表达式 [, 列名=表达式] ... [where 条件];

    - 当省略WHERE子句时，修改表中所有记录，否则仅修改满足条件的记录；
    - 条件也可以使用子查询

    update S set SA=SA+1;

*** delete
    delete from 表名 [where 条件];

    - 只能删除表记录，删除表结构用 drop table
    - 为物理删除命令
    - 无条件时，删除全部记录

    delete from SC where G < 60;

*** index
    索引分聚簇索引(CLUSTER)、唯一索引(UNIQUE)。

    改变记录的物理存储顺序使之与索引项值的排列顺序相同，称为聚簇索引。

**** create index
     create [UNIQUE] [CLUSTER] index 索引名 on 表名 (列名 {ASC, DESC} [, 列名 {ASC, DESC}]);

**** drop index
     drop index 索引名

** view
   - 视图是从一个或几个基本表（或视图）导出的表（用户外模式是由若干基本表和/或若
     干视图构成的）。
   - 视图是一个虚表，只存储视图的定义，数据存在所基于的基本表中。
   - 视图定义后就可象基本表一样来使用
     - 可创建、删除视图
     - 可用来定义新的视图
     - 可在视图上查询（SELECT）
     - 可更新（INSERT， DELETE， UPDATE）视图，但受限制

*** create view
    create view 视图名 [(列名 [, 列名] ...)] as 子查询 [with check-option];

    - 组成视图的属性列名，要么全部写出，要么全部省略，省略时，隐含视图的属性列同
      子查询的目标列。当SELECT语句中有库函数、或字段表达式、或多表连接有同名字段
      时，则视图中必须指定字段名
    - 视图中字段名可以和基本表中的字段名不同
    - 没有修改视图的方法，要实现此功能，唯一的途径是先 删除，再重建。
    - 视图的子查询可以基于一个或多个基本表或/和视图上

    create view CS_S as select SN, SA from S where SD='CS';
    create view S_G(SN, GAVG) as select SN, avg(G) from SC group by SN;
*** drop view
    - 删除基本表或视图后，由被删除的基本表或视图导出的视图仍然存在，但已无法使用，
      需另行删除

    drop view 视图名
*** 视图查询
    执行过程： 从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，
    转换成等价的对基本表的查询，最后在基本表上执行修改后的查询，这一转换称为视图
    消解。

    *注意* ： 当视图中的字段对应的是一个库函数或字段表达式时，有些系统 转换后的查询可能会
    不正确
*** 视图上的更新（ISNERT， DELETE， UPDATE）
    执行过程： 将对视图的更新语句转化为对相应的基本表的更新语句，然后执行。为防止更新基本表
    中不属于本视图的数据，可在视图定义时加上WITH CHECK OPTION子句。
    *注意* ：
    - 不是所有的视图更新都可正确转化为对基本表的更新语句
    - 有些视图是可更新的, 有些视图是不可更新的
    - 肯定可以更新的视图是行列子集视图(从单个表导出，且只是去掉了基本表的某些行
      和某些列并保留了码)
    - 处理方式：只有从单个表导出的视图才允许更新操作，且作一系列的限制
    - 从概念上分清不可更新视图和不允许更新视图。
*** 视图的优点
    1、能够简化用户的操作
    2、用户能以不同的方式对待同一数据，方便灵活
    3、提供一定程度的逻辑独立性
    4、有利于安全保密

** 数据控制功能
   数据控制功能包括事物管理功能和数据保护功能，即数据的安全性、完整性、事务控制、
   并发控制和恢复功能。

*** 授权
    grant 权限 [, 权限] ... [on 对象类型 对象名] to 用户名 [, 用户名] ... [with grant-option];
    revoke
* 事务
  为保证数据的一致性，大型数据库系统一般都提供若干策略：
  - 删除主表（被参照表）中的数据时
    1. 自动删除参照表中的相应数据；
    2. 检查参照表中是否有数据参照，若有则拒绝删除。
  - 向参照表中插入数据时
    1. 检查所有被参照表中是否有被参照的信息，若没有则拒
       绝插入
  - 修改主表中的被参照字段
    1. 检查参照表中是否有数据参照，若有则拒绝修改。
** 并发控制
   事务是并发控制的基本单位，保证事务的ACID特性是事务处理的主要任务。
*** 并发可能带来的一致性问题
    1. 丢失修改

       当两个事务读入同一个数据，并同时修改此数据，一个事务提交的结果覆盖了另一个事务提交的结果，导致修改丢失。此
       种情形的纠正方式是当结果修改后，另一事务能立即观察到此修改。

    2. 不可重复读

       当一个事务修改了一个数据后，另一事务无法再现前一次读取的数据结果。包括三种情况：
       - 数据结果已改变
       - 数据被删除或不存在
       - 数据结果记录增多

    3. 读脏数据

       一个事务提交结果后，被另一事务读取，当前者因故又取消了提交，导致后者读到的数据因取消而变成了脏数据。

*** 并发控制的手段
    主要有封锁、时间戳、乐观控制法。

**** 封锁
     锁有两种类型：
     1. 排它锁(Exclusive Locks，也叫写锁)

        当一个事务对数据A加上写锁后，则只允许此事务读写数据A，其他任何事务不能对
        A加任何类型的锁，直到事务完成并释放A上的写锁。

     2. 共享锁(Share Locks，也叫读锁)

        当一个事务对数据A加上读锁后，则只允许此事务读数据A，不能修改数据A，其他
        事务只能对A加读锁，而不能加写锁，直到此事务完成并释放A上的读锁。

     活锁：当多个事务请求封锁同一数据时，按请求封锁的先后次序对事务排除，避免了
     一个事务因总是请求不到锁而得不到执行。

     死锁：当两个事务互相请求对方封锁的数据后，导致互相等等，永远无法执行的问题。
     解决方法：
     1. 预防处理
        1. 一次封锁法：每个事务必须一次将所有要使用的数据全部加锁（问题：1. 扩大
           了封锁的范围，降低了系统并发度；2. 数据是变化的，很难事先精确确定每个
           事务所要封锁的数据，为此只能扩大封锁范围，进一步降低了并发度）
        2. 顺序封锁法：预先对数据规定一个封锁顺序，所有事务都按这个顺序进行封锁
           （问题：1.封锁的数据极多，且随着数据的插入、删除，维护这样的资源封锁
           顺序非常困难；2. 很难事先确定一个事务要封锁哪些对象，也就不所谓顺序）

     2. 事后处理
        1. 超时法：事务的等待时间超过了规定的时限，就认为发生了死锁（不足：1. 事
           务因非死锁问题导致超时，系统会误认为发生了死锁；2.时限设置矿长，死锁
           发生后不能及时发现）

        2. 等待图法



**** 并发调度的可串行性
     多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务的
     结果相同，则称这种调度策略为可串行化调度。

* 数据库设计
  需求分析、概念设计、逻辑设计、物理设计
** 需求分析
** 概念设计
   概念结构设计的第一步是利用抽象机制对需求分析阶段收集的数据进行分类、组织（聚
   集），形成实体、实体的属性，标识实体的码，确定实体之间的联系(1:1， 1:m， n:m)，
   设计分E-R图。
** 逻辑设计
   逻辑结构分三步进行：
   1. 将概念结构转换成一般的关系、层次、网状模型
   2. 将转换来的关系、层次、网状模型向特定的DBMS支持下的数据模型转换
   3. 对数据模型进行优化
** 物理设计
* 常见的数据库优化策略
  1. 选取最合适的字段属性，尽量减小表的大小
  2. 使用Join代替子查询
  3. 使用联合代替手动创建的临时表
  4. 使用索引
     1. 不要对含有大量重复数据的字段建立索引
     2. 尽量在那些将用于join, where, order by中的字段建立索引
  5. 优化查询语句
     1. 最好在类型相同的字段间进行比较操作
     2. 在建有索引的字段上尽量不要使用函数进行操作

	
  数据库访问优化漏斗法则：
  1. 减少磁盘访问（减少数据访问(1-1000)，返回更少的数据(1-100)）
  2. 减少网络传输（返回更少的数据，减少交互次数(1-20)）
  3. 减少CPU开销和内存开销（减少服务器CPU开销(1-5)）
  4. 增加资源（利用更多资源1-10）
  
