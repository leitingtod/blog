* Basic
  REFS:
  - http://blog.csdn.net/u013551462/article/details/50956090
  - http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html
  - http://www.tvtv223.com/so/8/default/8.html
  Java语言（java.long.*）
  Java集合框架（java.util.*）
  Java I/O（java.io.*、java.nio.*.*）
  Java 网络（java.net.*、java.rmi.*、javax.net.*）
  Java 并发（java.util.concurrent.*、java.util.concurrent.*.*）
** static
   static可修饰变量，函数，类，包导入、代码块，根据作用域的不同，呈现不同的效果。
*** 静态内部类
    REFS:
    - http://blog.csdn.net/fgakjfd/article/details/5282646
    - http://blog.csdn.net/vange/article/details/5407625

    字面上看，一个被称为静态嵌套类，一个被称为内部类。从字面的角度解释是这样的：
    什么是嵌套？嵌套就是我跟你没关系，自己可以完全独立存在，但是我就想借你的壳用
    一下，来隐藏一下我自己（真TM猥琐）。什么是内部？内部就是我是你的一部分，我了
    解你，我知道你的全部，没有你就没有我。（所以内部类对象是以外部类对象存在为前
    提的）

    如果你不需要内部类对象与其外围类对象之间有联系，那你可以将内部类声明为static。
    这通常称为嵌套类（nested class）。Static Nested Class是被声明为静态（static）
    的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化
    后才能实例化。想要理解static应用于内部类时的含义，你就必须记住，普通的内部类
    对象隐含地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，
    就不是这样了。嵌套类意味着：
    1. 嵌套类的对象，并不需要其外围类的对象。
    2. 不能从嵌套类的对象中访问非静态的外围类对象。
    3. 静态内部类可以用public,protected,private修饰
    4. 静态内部类中可以定义静态或者非静态的成员
    5. 不能直接访问外部类的非静态成员
    6. 静态内部类不能访问外部类的非静态成员(包括非静态变量和非静态方法)
    7. 静态内部类只能访问外部类的静态成员(包括静态变量和静态方法)
    8. 外部类访问内部类的非静态成员:实例化内部类即可


    在开发过程中，内部类中使用的最多的还是非静态地成员内部类。不过在特定的情况
    下，静态内部类也能够发挥其独特的作用。

    静态内部类在Java语言中是一个很特殊的类，跟普通的静态类以及非静态的内部类都有
    很大的差异。作为程序开发人员，必须要知道他们之间 的差异，并在实际工作中在合
    适的地方采用合适的类。不过总的来说，静态内部类的使用频率并不是很高。但是在有
    一些场合，如果没有这个内部静态类的话，可能会起到事倍功半的反面效果。

    在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变
    为了静态内部类。不过由于种种的原因，如使用上的限制等 等因素(具体的使用限制，
    笔者在下面的内容中会详细阐述)，在实际工作中用的并不是很多。但是并不是说其没
    有价值。在某些特殊的情况下，少了这个静态内部 类还真是不行。如在进行代码程序
    测试的时候，如果在每一个Java源文件中都设置一个主方法(主方法是某个应用程序的
    入口，必须具有)，那么会出现很多额 外的代码。而且最主要的时这段主程序的代码对
    于Java文件来说，只是一个形式，其本身并不需要这种主方法。但是少了这个主方法又
    是万万不行的。在这种情 况下，就可以将主方法写入到静态内部类中，从而不用为每
    个Java源文件都设置一个类似的主方法。这对于代码测试是非常有用的。在一些中大型
    的应用程序开 发中，则是一个常用的技术手段。为此，这个静态内部类虽然不怎么常
    用，但是程序开发人员还必须要掌握它。也许在某个关键的时刻，其还可以发挥巨大的
    作用也 说不定。


*** 静态导入
    静态导入的语法是：
    - import static 包名.类名.静态成员变量;
    - import static 包名.类名.静态成员函数;

    要使用静态成员（方法和变量）我们必须给出提供这个静态成员的类。

 　　使用静态导入可以使被导入类的静态变量和静态方法在当前类直接可见，使用这些静
    态成员无需再给出他们的类名。

 　　过度地使用静态导入会在一定程度上降低代码的可读性。

** volatile
   REFS:
   - http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html
   - http://www.importnew.com/18126.html

   Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和
   volatile 关键字机制。

   一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就
   具备了两层语义：
   1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，
      这新值对其他线程来说是立即可见的。
   2. 禁止进行指令重排序。

   这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没
   能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变
   量的操作的原子性。

   根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作
   都是原子性的。

   用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。
   volatile很容易被误用，用来进行原子性操作。

   对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新
   的。用volatile关键字修改之后，还是会存在并发的情况。
** 可变长度参数
   可变长度参数必须作为方法参数列表中的的最后一个参数且方法参数列表中只能有一个
   可变长度参数。
   #+begin_src java
   public static void print(String... strs)
   {
       for (int i = 0; i < strs.length; i++)
       {
           System.out.println(strs[i]);
       }
   }
   #+end_src
** foreach原理
   REFS:
   - https://my.oschina.net/TJALS/blog/842691
   - http://www.cnblogs.com/xrq730/p/4868465.html

   Java提供给了用户大量的语法糖，比如泛型、自动装箱、自动拆箱、foreach循环、变长
   参数、内部类、枚举类、断言（assert）等。

   foreach 语句为数组或对象集合中的每个元素重复一个嵌入语句组。foreach 语句用于
   循环访问集合以获取所需信息，但不应用于更改集合内容以避免产生不可预知的副作用。

   foreach (int a in b) {}

   foreach循环的几个特性:
   1. foreach遍历不能对元素进行赋值操作
   2. 同时只能遍历一个
   3. 遍历的时候，只有当前被遍历的元素可见，其他不可见
   4. 只能正向遍历，不能反向
   5. foreach对ArrayList的遍历是因为其实现了Iterable接口,任何一个集合，无论是JDK
      提供的还是自己写的，只要想使用foreach循环遍历，就必须正确地实现Iterable接口

   在foreach循环中，迭代集合collectionObject的过程如下：
   1. 调用collectionObject.GetEnumerator(),返回一个IEnumerator引用。这个方法可以
      通过IEnumerable接口的实现代码来获得。但这是可选的。
   2. 调用返回的IEnumerator接口的MoveNext()方法。
   3. 如果MoveNext()方法返回true,就使用IEnumerator接口的Current属性获取对象的一
      个引用，用于foreach循环。
   4. 重复前面两步，直到MoveNext()方法返回false为止，此时循环停止。
** 类加载机制
   REFS:
   - http://blog.csdn.net/jintao_ma/article/details/51353453
*** 为什么要使用类加载器？
    Java语言里，类加载都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加
    一些性能开销，但是会给java应用程序提供高度的灵活性。例如：
    1. 编写一个面向接口的应用程序，可能等到运行时再指定其实现的子类；
    2. 用户可以自定义一个类加载器，让程序在运行时从网络或其他地方加载一个二进制
       流作为程序代码的一部分；(这个是Android插件化，动态安装更新apk的基础)

*** 类加载的过程
    类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：加载
    (Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化
    (Initialization)、使用(Using)、卸载(Unloading)七个阶段，其中验证、准备、解析
    三个部分统称链接。

    加载(装载)、验证、准备、初始化和卸载这五个阶段顺序是固定的，类的加载过程必须
    按照这种顺序开始，而解析阶段不一定；它在某些情况下可以在初始化之后再开始，这
    是为了运行时动态绑定特性（JIT例如接口只在调用的时候才知道具体实现的是哪个子
    类）。值得注意的是：这些阶段通常都是互相交叉的混合式进行的，通常会在一个阶段
    执行的过程中调用或激活另外一个阶段。

*** 类加载器
    JVM设计者把类加载阶段中的“通过'类全名'来获取定义此类的二进制字节流”这个动
    作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现
    这个动作的代码模块称为“类加载器”。

    1. 类与类加载器

       对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。
       也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类
       才相等。
    2. 双亲委派模型

       从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器
       （Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一
       部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立
       于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。

       从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类
       加载器：

       1. 启动类加载器

       2. 扩展类加载器

       3. 应用类加载器

       4. 自定义类加载器

       类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启
       动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加
       载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关
       系来复用父加载器的代码。


       双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会
       自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的
       加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父
       加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）
       时，子加载器才会尝试自己去加载。

       使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具
       备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去
       加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载
       器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个
       java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应
       用程序也会变得很混乱。

       若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其
       findClass()方法即可。

*** 动态加载Jar && ClassLoader 隔离问题
    ClassLoader 隔离问题：大家觉得一个运行程序中有没有可能同时存在两个包名和类名
    完全一致的类？

    JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所
    以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两
    个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，
    这就是 ClassLoader 隔离。

    加载不同 Jar 包中公共类：现在 Host 工程包含了 common.jar, jar1.jar, jar2.jar，
    并且 jar1.jar 和 jar2.jar 都包含了 common.jar，我们通过 ClassLoader 将 jar1,
    jar2 动态加载进来，这样在 Host 中实际是存在三份 common.jar，如下图：
    https://farm4.staticflickr.com/3872/14301963930_2f0f0fe8aa_o.png我们怎么保证
    common.jar 只有一份而不会造成上面3中提到的 ClassLoader 隔离的问题呢，其实很
    简单，在生成 jar1 和 jar2 时把 common.jar 去掉，只保留 host 中一份，以 host
    ClassLoader 为 parentClassLoader 即可。
** Java内存模型，Java内存管理，Java堆和栈，垃圾回收
   REFS:
   - http://www.jcp.org/en/jsr/detail?id=133
   - http://ifeve.com/jmm-faq/

   从1997年以来，人们不断发现Java语言规范的17章定义的Java内存模型中的一些严重的
   缺陷。这些缺陷会导致一些使人迷惑的行为（例如final字段会被观察到值的改变）和破
   坏编译器常见的优化能力。

   Java内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各
   种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存
   模型远比想象要更难。JSR133为Java语言定义了一个新的内存模型，它修复了早期内存
   模型中的缺陷。为了实现JSR133，final和volatile的语义需要重新定义。

   完整的语义见：http://www.cs.umd.edu/users/pugh/java/memoryModel，但是正式的语
   义不是小心翼翼的，它是令人惊讶和清醒的，目的是让人意识到一些看似简单的概念
   （如同步）其实有多复杂。幸运的是，你不需要懂得这些正式语义的细节——JSR133的目
   的是创建一组正式语义，这些正式语义提供了volatile、synchronzied和final如何工作
   的直观框架。

   Java包含了几个语言级别的关键字，包括：volatile, final以及synchronized，目的是
   为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和
   synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能
   正确的运行。

   大部分其他的语言，像C和C++，都没有被设计成直接支持多线程。这些语言对于发生在
   编译器和处理器平台架构的重排序行为的保护机制会严重的依赖于程序中所使用的线程
   库（例如pthreads），编译器，以及代码所运行的平台所提供的保障。

*** 重排序
    在很多情况下，访问一个程序变量（对象实例字段，类静态字段和数组元素）可能会使
    用不同的顺序执行，而不是程序语义所指定的顺序执行。编译器能够自由的以优化的名
    义去改变指令顺序。在特定的环境下，处理器可能会次序颠倒的执行指令。数据可能在
    寄存器，处理器缓冲区和主内存中以不同的次序移动，而不是按照程序指定的顺序。

    例如，如果一个线程写入值到字段a，然后写入值到字段b，而且b的值不依赖于a的值，
    那么，处理器就能够自由的调整它们的执行顺序，而且缓冲区能够在a之前刷新b的值到
    主内存。有许多潜在的重排序的来源，例如编译器，JIT以及缓冲区。

    大部分情况下，一个线程不会关注其他线程正在做什么，但是当它需要关注的时候，这
    时候就需要同步了。

** 同步
   同步有几个方面的作用。最广为人知的就是互斥 ——一次只有一个线程能够获得一个监视
   器，因此，在一个监视器上面同步意味着一旦一个线程进入到监视器保护的同步块中，
   其他的线程都不能进入到同一个监视器保护的块中间，除非第一个线程退出了同步块。


   但是同步的含义比互斥更广。同步保证了一个线程在同步块之前或者在同步块中的一个
   内存写入操作以可预知的方式对其他有相同监视器的线程可见。当我们退出了同步块，
   我们就释放了这个监视器，这个监视器有刷新缓冲区到主内存的效果，因此该线程的写
   入操作能够为其他线程所见。在我们进入一个同步块之前，我们需要获取监视器，监视
   器有使本地处理器缓存失效的功能，因此变量会从主存重新加载，于是其它线程对共享
   变量的修改对当前线程来说就变得可见了。

   对两个线程来说，为了正确建立happens before关系而在相同监视器上面进行同步是非
   常重要的。以下观点是错误的：当线程A在对象X上面同步的时候，所有东西对线程A可见，
   线程B在对象Y上面进行同步的时候，所有东西对线程B也是可见的。释放监视器和获取监
   视器必须匹配（也就是说要在相同的监视器上面完成这两个操作），否则，代码就会存
   在“数据竞争”。

   没有正确同步的代码对于不同的人来说可能会有不同的理解。在Java内存模型这个语义
   环境下，我们谈到“没有正确同步”，我们的意思是：
   - 一个线程中有一个对变量的写操作，
   - 另外一个线程对同一个变量有读操作，
   - 而且写操作和读操作没有通过同步来保证顺序。

   当这些规则被违反的时候，我们就说在这个变量上有一个“数据竞争”(data race)。一
   个有数据竞争的程序就是一个没有正确同步的程序。
** 日志
   8.1 jdk自带的logging、log4j、log4j2、logback
   8.2 门面commons-logging、slf4j
   8.3 上述6种混战时的日志转换
** Callable, Runnable
   Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，
   并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回
   值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值，

   FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执
   行，又可以作为Future得到Callable的返回值，那么这个组合的使用有什么好处呢？假
   设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使
   用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其
   它的操作，等到需要这个返回值时，再通过Future得到，岂不美哉！

   另一种方式使用Callable和Future，通过ExecutorService的submit方法执行Callable，
   并返回Future。代码是不是简化了很多，ExecutorService继承自Executor，它的目的是
   为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的
   生命周期，是JDK 5之后启动任务的首选方式。
** 线程池
   REFS:
   - http://blog.csdn.net/ghsau/article/details/7443324

   四种不同的线程池：
   - Fixed
   - Cached
   - Single
   - Scheduled
** CAS

* 网络编程知识
** HTTPS的实现原理
** Java RMI，Socket，HttpClient
** NIO模块以及对应的Netty和Mina、thrift源码
   4.1 TCP握手和断开及有限状态机
   4.2 backlog
   4.3 BIO NIO
   4.4 阻塞/非阻塞的区别、同步/异步的区别
   4.5 阻塞IO、非阻塞IO、多路复用IO、异步IO
   4.6 Reactor线程模型
   4.7 jdk的poll、epoll与底层poll、epoll的对接实现
   4.8 Netty自己的epoll实现
   4.9 内核层poll、epoll的大致实现
   4.10 epoll的边缘触发和水平触发
   4.11 Netty的EventLoopGroup设计
   4.12 Netty的ByteBuf设计
   4.13 Netty的ChannelHandler
   4.13 Netty的零拷贝
   4.14 Netty的线程模型，特别是与业务线程以及资源释放方面的理解
** 用Java写一个简单的静态文件的HTTP服务器
   - 实现客户端缓存功能，支持返回304
   - 实现可并发下载一个文件
   - 使用线程池处理客户端请求
   - 使用nio处理客户端请求
   - 支持简单的rewrite规则
   - 上述功能在实现的时候需要满足“开闭原则”
** 了解nginx和apache服务器的特性并搭建一个对应的服务器
* 框架知识
** [[file:spring.org][Spring]]
** ORM框架: mybatis、Hibernate
   最原始的jdbc->Spring的JdbcTemplate->hibernate->JPA->SpringDataJPA的演进之路
** 用spring和ibatis搭建java server
** RPC框架dubbo源码
* 应用服务器知识
** 熟悉使用jboss，https://www.jboss.org/overview/
** 熟悉使用tomcat，http://tomcat.apache.org/
   9.1 tomcat的整体架构设计
   9.2 tomcat对通信的并发控制
   9.3 http请求到达tomcat的整个处理流程
** 熟悉使用jetty，http://www.eclipse.org/jetty/
* 操作系统知识
** 关系型数据库
** NoSQL
* 大数据知识
* 网络安全知识
* Lock 与 synchronized 的区别
  REFS:
  1. http://www.cnblogs.com/nsw2018/p/5821738.html
  2. http://www.cnblogs.com/benshan/p/3551987.html


  1. synchronized是在JVM层面上实现的，不但可通过一些监控工具监控 synchronized 的
     锁定，而且代码执行出现异常时，JVM会自动释放锁定。但Lock不行，其是通过代码实
     现的，要保证锁一定会被释放，就必须将unLock放到 finally {} 中。
  2. 在并发量比较小的情况下，使用synchronized是个不错的选择，但是在并发量比较高
     的情况下，其性能下降很严重，此时ReentrantLock是个不错的方案。
  3. ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定
     时锁等候和中断锁等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。
     但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而
     ReentrantLock确还能维持常态。


  我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。
  ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。

** 使用
   需要对一个方法进行同步，那么只需在方法的签名添加一个synchronized关键字。
  #+begin_src java
  // 未同步的方法
  public void test() {}

  // 同步的方法
  pubilc synchronized void test() {}

  public void test() {
     synchronized(obj) {
     // 当 obj == this 时， 等同于 同步的方法
          System.out.println("===");
     }
  }
  #+end_src

  使用synchronized代码块，可以只对需要同步的代码进行同步，这样可以大大的提高效率。

  使用synchronized 代码块相比方法有两点优势：
  1. 可以只对需要同步的使用
  2. 与wait()/notify()/nitifyAll()一起使用时，比较方便

* JVM
* 理解Java中的弱引用
  我面试了一些求职Java高级开发工程师的应聘者。我常常会面试他们说，“你能给我介绍
  一些Java中得弱引用吗？”，如果面试者这样说，“嗯，是不是垃圾回收有关的？”，我
  就会基本满意了，我并不期待回答是一篇诘究本末的论文描述
** 强引用
** 软引用
** 弱引用
** 虚引用
